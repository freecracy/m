(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{563:function(s,t,a){"use strict";a.r(t);var n=a(20),e=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"_0x05-编译器02"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_0x05-编译器02"}},[s._v("#")]),s._v(" 0x05.编译器02")]),s._v(" "),a("h2",{attrs:{id:"伪寄存器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#伪寄存器"}},[s._v("#")]),s._v(" 伪寄存器")]),s._v(" "),a("ol",[a("li",[a("p",[s._v("FP,参数地址,指向又调用方提供的参数列表的起始地址,通过偏移量指向不同参数或返回值,通常在偏移量前包含参数名.")])]),s._v(" "),a("li",[a("p",[s._v("PC,指令地址,用来指令函数跳转")])]),s._v(" "),a("li",[a("p",[s._v("SB,全局符号地址,")])]),s._v(" "),a("li",[a("p",[s._v("SP,栈局部变量内存地址,")])])]),s._v(" "),a("p",[s._v('这个"". 代表的是这个函数的命名空间')]),s._v(" "),a("p",[s._v("FP是frame pointer，是指向栈底，SP是指向栈顶")]),s._v(" "),a("p",[s._v("BX是一个临时寄存器")]),s._v(" "),a("p",[s._v("JLE代表CMP比较之后的结果")]),s._v(" "),a("p",[s._v("CMPQ来进行比较的")]),s._v(" "),a("p",[s._v('go build -gcflags="-S -N" test.go')]),s._v(" "),a("p",[s._v("go:noescape 将其转换，强制分配在函数栈上")]),s._v(" "),a("p",[s._v("golang编译器拥有逃逸分 析，用于决定每一个变量是分配在堆内存上 还是函数栈上")]),s._v(" "),a("p",[s._v("所有用户空间的数据都可以通过FP(局部数据、输入参数、返回值)或 SB(全局数据)访问。 通常情况下，不会对 SB / FP 寄存器进行运算操 作，通常情况以会以 SB / FP 作为基准地址，进行偏移解引用 等操作。")]),s._v(" "),a("p",[s._v("而且在某些情况下 SB 更像一些声明标识，其标识语句的作用")]),s._v(" "),a("p",[s._v("FP 伪寄存器用来标识函数参数、返回值")]),s._v(" "),a("p",[s._v("SP 是栈指针寄存器，指向当前函数栈的栈顶")]),s._v(" "),a("p",[s._v("但是硬件寄存器中也有一个 SP 。在用户手写的汇编代码中，如果操作 S P 寄存器时没有带 symbol 前缀，则操作的是 硬件寄存器 SP")]),s._v(" "),a("p",[s._v("此处声明了一个函数 profileloop ，函数的声明以 TEXT 标识开头，以 ${package}·${function} 为函数名。 如何函数属于本package时，通常 可以不写 ${package} ，只留 ·${function} 即可。 · 在mac上可以用 shift+option+9 打出。 $8 表示该函数栈大小为8byte，计算栈大小 时，需要考虑局部变量和本函数内调用其他函数时，需要传参的空间，")]),s._v(" "),a("p",[s._v("$16 表示该函数 入参和返回值一共有16byte。当有 NOSPLIT 标识时，可以不写输入参 数、返回值占用的大小。")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://tva1.sinaimg.cn/large/006tNbRwly1gauz1tqu94j31e60u07wh.jpg",alt:"image-20200113153527666"}})]),s._v(" "),a("p",[s._v("该函数没有局部变量，故 $ 后第一个数为0，但其有2个输入参数，1个返 回值，每个值占8byte，则第二个数为24(3*8byte)")]),s._v(" "),a("p",[s._v("string底层是stringHeader,slice底层是sliceHeader,")]),s._v(" "),a("p",[s._v("map 是指向 hmap 的一个 unsafe.Pointer")]),s._v(" "),a("p",[s._v("chan 是指向 hchan 的一个 unsafe.Pointer")]),s._v(" "),a("p",[s._v("interface{} 是 eface 这样一个结构体")]),s._v(" "),a("p",[s._v("因此被调用函数的参数、返回值、 栈位置都需要由调用者维护、准备,")]),s._v(" "),a("p",[s._v("方能调用下一个函数，另外这些都需要进行内存 对其，对其 的大小是 sizeof(uintptr)")]),s._v(" "),a("p",[s._v("对于手写汇编来说，所有参数通过栈来传递，通过伪寄存器 FP 偏移进行 访问。函数的返回值跟随在输入参数 后面，并且对其到指针大小")]),s._v(" "),a("p",[s._v("当函数中有局部变量时，我们就需要移动函数栈帧来进行栈内存分配")]),s._v(" "),a("p",[s._v("// 编译")]),s._v(" "),a("p",[s._v('go build -gcflags**=**"-S"')]),s._v(" "),a("p",[s._v("go tool compile -S hello.go")]),s._v(" "),a("p",[s._v("go tool compile -l -N -S hello.go // 禁止内联 禁止优化")]),s._v(" "),a("p",[s._v("// 反编译")]),s._v(" "),a("p",[s._v("go tool objdump "),a("binary")],1),s._v(" "),a("h2",{attrs:{id:"重定向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重定向"}},[s._v("#")]),s._v(" 重定向")]),s._v(" "),a("div",{staticClass:"language-go line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("package")]),s._v(" main\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("import")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"fmt"')]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("func")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n\tfmt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("Println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"hello world"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("分别编译 main.go 和 fmt/print.go 到 main.o 和 print.o")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("go tool compile -S -l main.go "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 查看生成的文件和汇编代码, -l 避免内连,方便理解")]),s._v("\ngo tool compile objdump main.o "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 反汇编生成的 main.go,结果中标识符 R_CALL 代表重定位调用")]),s._v("\ngo tool compile nm main.o "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 由于 println 属于另一个包,编译器不知道在何处,符号 U 代表未定义,表示编译器不知道该符号在哪里")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 必须重定位此符号,查找 println 的地址调用成功.这是连接器所处的位置.")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# cmd/internal/objabi 定义了 .o 文件的格式")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# hex 查看 main.o 符号位均以十六进制 fe 开头.")]),s._v("\nobjdump -h 二进制文件 "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 可视化每个部分地址,函数主题位于 __TEXT 部分")]),s._v("\nobjdump -d 二机制文件 "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 可以找到")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("p",[s._v("函数 main 的分配地址,函数 fmt.println 的地址,连接器只要计算 println 的地址减去 main 的偏移量,然后用全局偏移量就可以调用了.")])])}),[],!1,null,null,null);t.default=e.exports}}]);