(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{409:function(t,a,e){t.exports=e.p+"assets/img/redis-qidong.0c00fd04.png"},410:function(t,a,e){t.exports=e.p+"assets/img/redis-danxiancheng.4bd469ee.png"},411:function(t,a,e){t.exports=e.p+"assets/img/redis-duoxiancheng.fca90a63.png"},412:function(t,a,e){t.exports=e.p+"assets/img/redis-xiancheng.b25a67f5.png"},520:function(t,a,e){"use strict";e.r(a);var r=e(20),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"基础"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),r("h2",{attrs:{id:"_8-种淘汰策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8-种淘汰策略"}},[t._v("#")]),t._v(" 8 种淘汰策略")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("淘汰策略")]),t._v(" "),r("th",[t._v("说明")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("volatile-lru")]),t._v(" "),r("td",[t._v("根据 lru 算法,删除设置了过期时间的键,如果没有则报错")])]),t._v(" "),r("tr",[r("td",[t._v("allkeys-lru")]),t._v(" "),r("td",[t._v("根据 lru 算法,删除所有键,如果没有则报错")])]),t._v(" "),r("tr",[r("td",[t._v("volatile-lfu")]),t._v(" "),r("td",[t._v("根据 lru 算法,删除设置列过期时间的键,如果没有则报错")])]),t._v(" "),r("tr",[r("td",[t._v("allkeys-lfu")]),t._v(" "),r("td",[t._v("根据 lfu 算法,删除所有键,如果没有则报错")])]),t._v(" "),r("tr",[r("td",[t._v("volatile-random")]),t._v(" "),r("td",[t._v("随机删除设置了过期 key 的键,如果没有可删除的键,则报错")])]),t._v(" "),r("tr",[r("td",[t._v("allkeys-random")]),t._v(" "),r("td",[t._v("速记删除所有键,如果没有可删除的键对象,且内存还是不够用,则报错")])]),t._v(" "),r("tr",[r("td",[t._v("volatile-ttl")]),t._v(" "),r("td",[t._v("根据 ttl 属性,删除最近将要过期的,如果没有直接报错")])]),t._v(" "),r("tr",[r("td",[t._v("noeviction")]),t._v(" "),r("td",[t._v("默认策略,不做任何处理,直接报错")])])])]),t._v(" "),r("h2",{attrs:{id:"lru-算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#lru-算法"}},[t._v("#")]),t._v(" lru 算法")]),t._v(" "),r("p",[t._v("最近最长时间未使用,主要是时间")]),t._v(" "),r("h3",{attrs:{id:"传统-lru-算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#传统-lru-算法"}},[t._v("#")]),t._v(" 传统 lru 算法")]),t._v(" "),r("ol",[r("li",[t._v("需要额外空间存储")]),t._v(" "),r("li",[t._v("可能某个 key 使用很频繁,但是最近没有使用,而被 lru 算法删除")])]),t._v(" "),r("h3",{attrs:{id:"改进后的-lru-算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#改进后的-lru-算法"}},[t._v("#")]),t._v(" 改进后的 lru 算法")]),t._v(" "),r("p",[r("code",[t._v("maxmemory_samples 5")]),t._v("表示随机抽取 5 个 key,然后对这个 5 个 key 按照 lru 算法删除")]),t._v(" "),r("h2",{attrs:{id:"多线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#多线程"}},[t._v("#")]),t._v(" 多线程")]),t._v(" "),r("p",[t._v("6.0 对网络请求引入了多线程,读写操作还是单线程.")]),t._v(" "),r("h2",{attrs:{id:"redis-启动流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis-启动流程"}},[t._v("#")]),t._v(" REDIS 启动流程")]),t._v(" "),r("ol",[r("li",[t._v("listenToPort : socket bind listen , 建立 tcp 监听,返回一个文件描述符 fd")]),t._v(" "),r("li",[t._v("通过 aeCreateFileEvent 方法将 fd 加入到 aeFileEvent 链表中,同时将文件描述符绑定函数 acceptHandler 这样当客户端连接进来时就会执行这个函数")]),t._v(" "),r("li",[t._v("等待客户端连接")]),t._v(" "),r("li",[t._v("当有客户端连接进来会调用 createClient 创建一个专属的 client 为其服务.仍然是 aeCreateFileEvent 把文件描述符挂载到链表上,然后分配一个处理函数,不再是处理客户端连接的 acceptHandler 而是处理客户端命令的 readQueryFromClient")]),t._v(" "),r("li",[t._v("如果有新的客户端不断的将新客户端的文件描述符挂载上去,而监听客户端连接的都是链表的第一个文件描述符")]),t._v(" "),r("li",[t._v("等待命令 : 只有一个线程循环调用 aeProcessEvents 函数,用 select 方式监听多个文件描述符,由于只有一个线程监听这些描述符,并处理,即时客户端并发发送命令,这里仍是依次取出,顺序执行.即 redis 是单线程的,命令与命令之间是顺序执行的,无需考虑线程安全")])]),t._v(" "),r("p",[r("img",{attrs:{src:e(409),alt:"redis-qidong"}})]),t._v(" "),r("h2",{attrs:{id:"redis-命令处理流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis-命令处理流程"}},[t._v("#")]),t._v(" REDIS 命令处理流程")]),t._v(" "),r("p",[t._v("readQueryFromClient 函数会去一张表中寻找命令对应的函数,即命令模式,如 set 对应 setCommand 函数.处理完命令不是同步写回去,也不是开启一个线程异步写,仍然是调用 aeCreateFileEvent 将 sendReplyToclient 函数挂载到需要响应客户端连接的文件描述符上")]),t._v(" "),r("h2",{attrs:{id:"reactor-模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#reactor-模式"}},[t._v("#")]),t._v(" Reactor 模式")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("监听客户端请求 : io 多路复用方式,监听多个文件描述符,即 aeMain")])]),t._v(" "),r("li",[r("p",[t._v("执行相应的函数处理请求 : 这个挂载在文件描述符上的函数即事件处理器,分为连接应答器(acceptHandler),命令请求处理器(readQueryFromClient),命令回复处理器(sendReplyToclient)")]),t._v(" "),r("blockquote",[r("p",[t._v("一个负责响应 io 事件,一个负责交给响应事件处理器去处理,即 Reactor 模式.")])])])]),t._v(" "),r("h2",{attrs:{id:"io-多路复用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#io-多路复用"}},[t._v("#")]),t._v(" IO 多路复用")]),t._v(" "),r("h2",{attrs:{id:"集群化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#集群化"}},[t._v("#")]),t._v(" 集群化")]),t._v(" "),r("ol",[r("li",[t._v("客户端分片 : 通过固定 hash 算法针对不同 key 计算 hash 值,然后对不同节点进行读写")]),t._v(" "),r("li",[t._v("codis : 请求转发(把整个集群划分 1024 个槽位,在读写请求时,计算 key 的 hash 值,然后根据对 1024 取模)、在线数据迁移(在线扩容,不影响客户端访问)")]),t._v(" "),r("li",[t._v("twemproxy : 只实现了请求路由转发")]),t._v(" "),r("li",[t._v("cluster : 官方集群方案")])]),t._v(" "),r("h2",{attrs:{id:"rehash"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rehash"}},[t._v("#")]),t._v(" rehash")]),t._v(" "),r("p",[t._v("针对新增 key,往 h[1] 里插入,针对读请求,先从 h[0] 读没找到再去 h[1] 找,删除和更新和读请求一样.先查找再操作.")]),t._v(" "),r("h2",{attrs:{id:"单线程-vs-多线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单线程-vs-多线程"}},[t._v("#")]),t._v(" 单线程 vs 多线程")]),t._v(" "),r("p",[t._v("6.0 之前的单线程 : 处理客户端请求时,包括获取( socket 读),解析,执行,内容返回 ( socket 写),都由一个顺序串行的主线程处理.执行命令阶段,由于单线程处理命令,每一条到达的命令不会立即执行,会进入一个 socket 队列,当 socket 可读则交给单线程事件分发器逐个被执行.此外有些用后台线程或子进程执行")]),t._v(" "),r("p",[r("img",{attrs:{src:e(410),alt:"redis-danxiancheng"}})]),t._v(" "),r("p",[t._v("6.0 之后 : 单线程处理网络读写速度跟不上底层网络硬件的速度.采用多个 io 线程来处理网络星球,多 io 线程模型只处理网络读写请求,对于读写命令,仍然是单线程处理.")]),t._v(" "),r("p",[r("img",{attrs:{src:e(411),alt:"redis-duoxiancheng"}})]),t._v(" "),r("h3",{attrs:{id:"主线程、io-线程协作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主线程、io-线程协作"}},[t._v("#")]),t._v(" 主线程、io 线程协作")]),t._v(" "),r("p",[r("img",{attrs:{src:e(412),alt:"redis-xiancheng"}})]),t._v(" "),r("ol",[r("li",[t._v("主线程负责接收建立连接请求,获取 socket 放入全局等待读处理队列")]),t._v(" "),r("li",[t._v("主线程通过轮询将可读 socket 分配给 io 线程")]),t._v(" "),r("li",[t._v("主线程等待 io 线程读取 socket 完成")]),t._v(" "),r("li",[t._v("主线程执行 io 线程读取和解析出来的请求命令")]),t._v(" "),r("li",[t._v("主线程等待 io 线程将执行结果回写 socket 完毕")]),t._v(" "),r("li",[t._v("主线程清空全局队列,等待客户端后续请求")])]),t._v(" "),r("h2",{attrs:{id:"持久化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#持久化"}},[t._v("#")]),t._v(" 持久化")]),t._v(" "),r("h3",{attrs:{id:"rdb"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[t._v("#")]),t._v(" rdb")]),t._v(" "),r("ul",[r("li",[t._v("save、bgsave")]),t._v(" "),r("li",[t._v("save n m (配置)")])]),t._v(" "),r("h3",{attrs:{id:"aof"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[t._v("#")]),t._v(" aof")]),t._v(" "),r("h2",{attrs:{id:"分布式锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分布式锁"}},[t._v("#")]),t._v(" 分布式锁")]),t._v(" "),r("p",[t._v("只要线程加锁成功了就会启动一个后台线程每隔一段时间检查一下,如果线程还持有锁,就会不断延长锁时间,解决锁过期释放业务没执行完问题.")]),t._v(" "),r("h2",{attrs:{id:"限流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#限流"}},[t._v("#")]),t._v(" 限流")]),t._v(" "),r("ul",[r("li",[t._v("setnx")]),t._v(" "),r("li",[t._v("zset : 滑动窗口,uuid(时间戳)")]),t._v(" "),r("li",[t._v("list : 令牌桶,leftpop 取令牌,定时任务生成令牌")])])])}),[],!1,null,null,null);a.default=s.exports}}]);