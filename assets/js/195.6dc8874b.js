(window.webpackJsonp=window.webpackJsonp||[]).push([[195],{774:function(a,t,r){"use strict";r.r(t);var s=r(20),l=Object(s.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"大文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#大文件"}},[a._v("#")]),a._v(" 大文件")]),a._v(" "),r("h2",{attrs:{id:"如何从-100-亿-url-中找出相同的-url"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何从-100-亿-url-中找出相同的-url"}},[a._v("#")]),a._v(" 如何从 100 亿 URL 中找出相同的 URL")]),a._v(" "),r("h3",{attrs:{id:"题目"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#题目"}},[a._v("#")]),a._v(" 题目")]),a._v(" "),r("p",[a._v("给定 a,b 两个文件各存放 50 亿 URL,每个 URL 各 64B,内存限制 4G,找出 a,b 文件中共同的 URL.")]),a._v(" "),r("h3",{attrs:{id:"方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#方案"}},[a._v("#")]),a._v(" 方案")]),a._v(" "),r("p",[a._v("遍历文件 a,对遍历到堆 URL 求 hahs(URL)%1000 根据结果把遍历到的 URL 存储到 a0,a1...a999,这样每个文件大小约 300MB,同样的方法遍历文件 b,把 b 中的 URL 存储到 b0,b1...b999 中,这样所有可能相同的 URL 都在对应的小文件中,不对应的小文件不可能有相同的 URL,接下来只要遍历 a0...a999 把 URL 存储到一个 hashset 中,然后遍历 b0...b999 看在 ai 中是否存在,如果存在则是共有 URL,把这些 URL 保存到一个单独的文件中.")]),a._v(" "),r("h2",{attrs:{id:"a-文件-32-亿-url-b-文件-64-亿-求-a、b-中公共-url-连接"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#a-文件-32-亿-url-b-文件-64-亿-求-a、b-中公共-url-连接"}},[a._v("#")]),a._v(" A 文件 32 亿 url B 文件 64 亿,求 A、B 中公共 url 连接")]),a._v(" "),r("ol",[r("li",[a._v("切分 : md5 取模,首字母分割,或 2 个字母分割,即哈希分治把大文件均匀切分成小文件")]),a._v(" "),r("li",[a._v("在每一组小文件中以 hash 方式查找相同 url,哈希查找速度最快")])]),a._v(" "),r("h2",{attrs:{id:"a-b-两个文件找出相同的-qq-号"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#a-b-两个文件找出相同的-qq-号"}},[a._v("#")]),a._v(" A B 两个文件找出相同的 qq 号")]),a._v(" "),r("ul",[r("li",[a._v("暴力循环(时间复杂度高)")]),a._v(" "),r("li",[a._v("hashmap(内存要求大)")]),a._v(" "),r("li",[a._v("分治切割文件(时间复杂度底,内存要求小)")]),a._v(" "),r("li",[a._v("bitmap(最优解)")])])])}),[],!1,null,null,null);t.default=l.exports}}]);