(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{482:function(t,_,v){t.exports=v.p+"assets/img/htts2zhenjiegou.124b3159.png"},483:function(t,_,v){t.exports=v.p+"assets/img/XSS.62a370af.png"},532:function(t,_,v){"use strict";v.r(_);var a=v(20),s=Object(a.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"https"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#https"}},[t._v("#")]),t._v(" HTTPS")]),t._v(" "),a("h2",{attrs:{id:"常见错误码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见错误码"}},[t._v("#")]),t._v(" 常见错误码")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("错误码")]),t._v(" "),a("th",[t._v("描述")]),t._v(" "),a("th",[t._v("说明")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("101")]),t._v(" "),a("td",[t._v("Switching Protocols")]),t._v(" "),a("td",[t._v("升级 websocket ,服务器同意变更返回 101")])]),t._v(" "),a("tr",[a("td",[t._v("206")]),t._v(" "),a("td",[t._v("Partial Content")]),t._v(" "),a("td",[t._v("range 请求正常返回 206")])]),t._v(" "),a("tr",[a("td",[t._v("403")]),t._v(" "),a("td",[t._v("Forbidden")]),t._v(" "),a("td",[t._v("权限禁止")])]),t._v(" "),a("tr",[a("td",[t._v("405")]),t._v(" "),a("td",[t._v("Method Not Allowed")]),t._v(" "),a("td",[t._v("请求方法不被允许")])]),t._v(" "),a("tr",[a("td",[t._v("416")]),t._v(" "),a("td",[t._v("Requested Range Not Satisfiable")]),t._v(" "),a("td",[t._v("请求范围不合法,如范围越界")])]),t._v(" "),a("tr",[a("td",[t._v("304")]),t._v(" "),a("td"),t._v(" "),a("td",[t._v("文件未修改")])])])]),t._v(" "),a("h2",{attrs:{id:"常见请求头"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见请求头"}},[t._v("#")]),t._v(" 常见请求头")]),t._v(" "),a("h3",{attrs:{id:"通用表头"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#通用表头"}},[t._v("#")]),t._v(" 通用表头")]),t._v(" "),a("h3",{attrs:{id:"请求头"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#请求头"}},[t._v("#")]),t._v(" 请求头")]),t._v(" "),a("h3",{attrs:{id:"响应头"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应头"}},[t._v("#")]),t._v(" 响应头")]),t._v(" "),a("h3",{attrs:{id:"post-常用格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#post-常用格式"}},[t._v("#")]),t._v(" post 常用格式")]),t._v(" "),a("h2",{attrs:{id:"浏览器存储"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器存储"}},[t._v("#")]),t._v(" 浏览器存储")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("类型")]),t._v(" "),a("th",[t._v("作用范围")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("cookie")]),t._v(" "),a("td",[t._v("约 4k,根据过期时间删除数据")])]),t._v(" "),a("tr",[a("td",[t._v("localstorage")]),t._v(" "),a("td",[t._v("约 4M,长时间保存,只能主动删除")])]),t._v(" "),a("tr",[a("td",[t._v("sessionstorage")]),t._v(" "),a("td",[t._v("约 4M,窗口关闭自动删除")])])])]),t._v(" "),a("h3",{attrs:{id:"http2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http2"}},[t._v("#")]),t._v(" HTTP2")]),t._v(" "),a("h3",{attrs:{id:"二进制帧结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二进制帧结构"}},[t._v("#")]),t._v(" 二进制帧结构")]),t._v(" "),a("p",[a("img",{attrs:{src:v(482),alt:"htts2zhenjiegou"}})]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("字段")]),t._v(" "),a("th",[t._v("长度")]),t._v(" "),a("th",[t._v("作用")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("length")]),t._v(" "),a("td",[t._v("3 字节")]),t._v(" "),a("td",[t._v("帧负载的长度")])]),t._v(" "),a("tr",[a("td",[t._v("type")]),t._v(" "),a("td",[t._v("1 字节")]),t._v(" "),a("td",[t._v("帧类型")])]),t._v(" "),a("tr",[a("td",[t._v("flags")]),t._v(" "),a("td",[t._v("1 字节")]),t._v(" "),a("td",[t._v("帧类型标识")])]),t._v(" "),a("tr",[a("td",[t._v("R")]),t._v(" "),a("td",[t._v("1 位")]),t._v(" "),a("td",[t._v("不要设置")])]),t._v(" "),a("tr",[a("td",[t._v("stream identifier")]),t._v(" "),a("td",[t._v("31 位")]),t._v(" "),a("td",[t._v("流 ID")])]),t._v(" "),a("tr",[a("td",[t._v("frame pay load")]),t._v(" "),a("td",[t._v("可变长度")]),t._v(" "),a("td",[t._v("帧内容")])])])]),t._v(" "),a("h2",{attrs:{id:"crsf"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#crsf"}},[t._v("#")]),t._v(" CRSF")]),t._v(" "),a("h3",{attrs:{id:"方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方式"}},[t._v("#")]),t._v(" 方式")]),t._v(" "),a("h3",{attrs:{id:"解决方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方法"}},[t._v("#")]),t._v(" 解决方法")]),t._v(" "),a("ol",[a("li",[t._v("token 验证 : 服务端下发 token 给客户端,客户端提交表单时携带 token ,服务端对 token 校验,每一次请求都带上随机码,由正常用户保存,黑客不知道随机码就无法冒充用户访问了, 如果是接口将 token 放入 header")]),t._v(" "),a("li",[t._v("隐藏 token : 将 1 中的 token 放 header 中")]),t._v(" "),a("li",[t._v("Refer 验证")]),t._v(" "),a("li",[t._v("验证码 : 恶意脚本不能识别复杂的验证码")])]),t._v(" "),a("h2",{attrs:{id:"xss"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#xss"}},[t._v("#")]),t._v(" XSS")]),t._v(" "),a("p",[a("img",{attrs:{src:v(483),alt:"XSS"}})]),t._v(" "),a("p",[t._v("本质是将用户数据当成 HTML 代码一部分来执行,混淆原本语义,产生新的语义.所有与用户交互的地方都有可能存在 XSS 攻击.")]),t._v(" "),a("ol",[a("li",[t._v("配置 http 中 http-only 让前端不能操作 cookie")]),t._v(" "),a("li",[t._v("输入检查,用户提交数据时使用 xssfilter 过滤不安全数据")]),t._v(" "),a("li",[t._v("输出检查,页面渲染时过滤掉危险数据")])]),t._v(" "),a("h2",{attrs:{id:"服务端攻击"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务端攻击"}},[t._v("#")]),t._v(" 服务端攻击")]),t._v(" "),a("h3",{attrs:{id:"sql-注入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sql-注入"}},[t._v("#")]),t._v(" sql 注入")]),t._v(" "),a("p",[t._v("sql 注入和 XSS 一样,都是违背数据和代码分离的原则导致的攻击方式.漏洞主要利用后端只是简单的拼接 sql 的方式查询数据.")]),t._v(" "),a("ol",[a("li",[t._v("sql 预编译, 参数绑定")]),t._v(" "),a("li",[t._v("去人数据类型,非类型转换")]),t._v(" "),a("li",[t._v("限制 sql 长度")]),t._v(" "),a("li",[t._v("控制数据库权限")]),t._v(" "),a("li",[t._v("避免直接响应 sql 异常, sql 发生异常时,自定义异常进行响应")]),t._v(" "),a("li",[t._v("过滤参数中含有的数据库关键词")])]),t._v(" "),a("h2",{attrs:{id:"localstorage-sessionstorage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#localstorage-sessionstorage"}},[t._v("#")]),t._v(" localstorage & sessionstorage")]),t._v(" "),a("p",[t._v("sessionstorage : 不同标签数据不共享")]),t._v(" "),a("p",[t._v("localstorage : 不同标签数据共享")]),t._v(" "),a("h2",{attrs:{id:"header-头注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#header-头注意事项"}},[t._v("#")]),t._v(" header 头注意事项")]),t._v(" "),a("ol",[a("li",[t._v("不区分大小写,通常首字母大写")]),t._v(" "),a("li",[t._v("字段名不允许有空格,可以使用"),a("code",[t._v("-")]),t._v("不能使用"),a("code",[t._v("_")])]),t._v(" "),a("li",[t._v("字段名必须紧接"),a("code",[t._v(":")]),t._v("不能有空格,但是"),a("code",[t._v(":")]),t._v("后面可以有空格")]),t._v(" "),a("li",[t._v("字段名顺序没有意义")])]),t._v(" "),a("h2",{attrs:{id:"引用层"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用层"}},[t._v("#")]),t._v(" 引用层")]),t._v(" "),a("p",[t._v("应用层工作在用户态,传输层及以下工作在内核态.")]),t._v(" "),a("h2",{attrs:{id:"http3-quic"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http3-quic"}},[t._v("#")]),t._v(" HTTP3(QUIC)")]),t._v(" "),a("p",[t._v("实现 tcp 可靠性,实现 TSL 层安全性")]),t._v(" "),a("h3",{attrs:{id:"多路复用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多路复用"}},[t._v("#")]),t._v(" 多路复用")]),t._v(" "),a("p",[t._v("tcp 存在队头阻塞问题,一个数据包没有按顺序到达,接收端会一直保持连接等待数据返回,就会阻塞后续请求 QUIC 在同一个物理连接上有多个独立逻辑数据流,并行在一个连接上传输,单个数据流可以保证有序,多个数据流无序互不影响.")]),t._v(" "),a("h3",{attrs:{id:"连接迁移"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#连接迁移"}},[t._v("#")]),t._v(" 连接迁移")]),t._v(" "),a("p",[t._v("tcp 连接的识别需要服务器和客户端 ip 和端口四个参数,如果网络切换,ip 会发生变化,导致之前的 tcp 失效需要重新建立连接.,QUIC 使用 uuid 标记每次连接,只要 uuid 不变就不需要握手,继续传输数据,")]),t._v(" "),a("h2",{attrs:{id:"time-wait"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#time-wait"}},[t._v("#")]),t._v(" time_wait")]),t._v(" "),a("h3",{attrs:{id:"原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[t._v("#")]),t._v(" 原因")]),t._v(" "),a("p",[t._v("四次挥手时会等待 2ML 的,所以可能会发生大量 time_wait 的存在.")]),t._v(" "),a("h3",{attrs:{id:"影响"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#影响"}},[t._v("#")]),t._v(" 影响")]),t._v(" "),a("ol",[a("li",[t._v("源端口数")]),t._v(" "),a("li",[t._v("文件描述符数")])]),t._v(" "),a("h3",{attrs:{id:"解决方法-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方法-2"}},[t._v("#")]),t._v(" 解决方法")]),t._v(" "),a("p",[t._v("修改网络配置,使用 socket 复用,即时释放资源")]),t._v(" "),a("ol",[a("li",[t._v("快速回收(recycle 内核 4.1 后被弃用)")]),t._v(" "),a("li",[t._v("重复利用(reuse,前提是开启 tcp_timestamps)")]),t._v(" "),a("li",[t._v("调大 time_wait 最大数量 (tcp_max_tw_buckets,默认 4096)")])]),t._v(" "),a("h2",{attrs:{id:"close-wait"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#close-wait"}},[t._v("#")]),t._v(" close_wait")]),t._v(" "),a("h3",{attrs:{id:"解决方法-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方法-3"}},[t._v("#")]),t._v(" 解决方法")]),t._v(" "),a("ol",[a("li",[t._v("修改网络配置减少 close_wait 时间")]),t._v(" "),a("li",[t._v("一般都是服务端代码问题")])]),t._v(" "),a("h2",{attrs:{id:"tcp-保护"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-保护"}},[t._v("#")]),t._v(" tcp 保护")]),t._v(" "),a("p",[t._v("定义一段时间,在这个时间内如果没有任何活动,tcp 保活机制开始作用,每隔一段时间发送一个探测报文,如果连续几个探测报文没有得到响应,则认为当前连接已死亡,系统内核将错误信息通知上层应用.在没有数据交互时通过保活机制确定对方连接是否存活.socket 接口设置 so_keeplive 选项开启保活机制.")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("参数")]),t._v(" "),a("th",[t._v("含义")]),t._v(" "),a("th",[t._v("默认值")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("net.ipv4.tcp_keeplive_time")]),t._v(" "),a("td",[t._v("如果 2 小时没有活动,启动保活机制")]),t._v(" "),a("td",[t._v("7200s(2 小时)")])]),t._v(" "),a("tr",[a("td",[t._v("net.ipv4.tcp_keeplive_intvl")]),t._v(" "),a("td",[t._v("每次检测间隔 75s")]),t._v(" "),a("td",[t._v("75s")])]),t._v(" "),a("tr",[a("td",[t._v("net.ipv4.tcp_keeplive_probes")]),t._v(" "),a("td",[t._v("检测 9 次无响应,认为对方不可达,中断本次连接")]),t._v(" "),a("td",[t._v("9")])]),t._v(" "),a("tr",[a("td",[t._v("net.ipv4.tcp_retries2")]),t._v(" "),a("td",[t._v("重传次数")]),t._v(" "),a("td",[t._v("15")])])])]),t._v(" "),a("ol",[a("li",[t._v("如果正常工作,保活时间被重置")]),t._v(" "),a("li",[t._v("如果主机宕机,存在保活机制,导致报文不可达,报告该连接已死亡")]),t._v(" "),a("li",[t._v("如果主机宕机,服务端无法感知,没开启 keepalive 又没有数据交互,不武断 tcp 一直处于 established 状态,直到服务端进程重启")]),t._v(" "),a("li",[t._v("如果进程崩溃,即时没有开启保活,双方没有数据交互,如果进程崩溃,这个过程操作系统时可以感知的,会发送 fin 报文给对方,断开连接")]),t._v(" "),a("li",[t._v("如果有数据传输,客户端重启后会回复 rst 重置连接")]),t._v(" "),a("li",[t._v("如果有数据传输,客户端一直不重启,会重传,在重传报文一直没有收到对方响应时,先到达最大重传次数,或者最大超时时间,其中一个条件就会停止重传")])]),t._v(" "),a("h2",{attrs:{id:"http3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http3"}},[t._v("#")]),t._v(" http3")]),t._v(" "),a("h3",{attrs:{id:"quic"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#quic"}},[t._v("#")]),t._v(" quic")]),t._v(" "),a("h2",{attrs:{id:"网络"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络"}},[t._v("#")]),t._v(" 网络")]),t._v(" "),a("p",[t._v("在传输层叫分段,在网络层叫分片,在 tcp 里长度是 MSS,在 ip 层这个长度是 MTU.")]),t._v(" "),a("p",[t._v("MSS : tcp 层提交给 ip 层的最大分段大小,不包含 tcp header 和 tcp option,只包含 tcp playload,是用来限制应用层最大发送字节数.")]),t._v(" "),a("p",[t._v("MSS = MTU - 20 (ip header) - 20 (tcp header)")]),t._v(" "),a("p",[t._v("查看 MSS : tcp header 头中有该字段")]),t._v(" "),a("p",[t._v("MSS 协商时取最小值.如果没有收到 MSS 字段,默认 536,即 536 + 20 + 20 = 576 是 ip 最小重组缓冲区的大小.")]),t._v(" "),a("p",[t._v("MTU : 最大传输单元,由数据链路层提供,为了告诉上层 ip 层自己的传输能力是多大,ip 层就会根据它进行数据包切片.")]),t._v(" "),a("p",[t._v("查看 MTU : ipconfig")]),t._v(" "),a("p",[t._v("正常情况下 传输层做的分段, ip 层就不会分片了,如果传输层没有分段(UDP),ip 层就会分片.")]),t._v(" "),a("p",[t._v("PMTU : 整个链路上最小 MTU,")]),t._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("cat")]),t._v(" /proc/sys/net/ipv4/ip_no_pmtu_disc "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 0 默认 0 开启 PMTU 发现功能")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("如果路由器收到大于当前 MTU 的分片时会查看 DF 的值,如果 0 允许分片,继续传递,如果是 1,就会把数据丢弃,同时返回一个 ICMP 包给发送端,数据不可达需要分片,同时带上当前机器的 MTU.")]),t._v(" "),a("h2",{attrs:{id:"keepalive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keepalive"}},[t._v("#")]),t._v(" keepalive")]),t._v(" "),a("ol",[a("li",[t._v("http 的 keep-alive : 应用层,即用户态实现,称为 http 长连接,header 头 connection:keep-alive,避免浪费资源会设置 keepalive-timeout 参数,指定长连接超时时间,通过定时器来释放连接")]),t._v(" "),a("li",[t._v("tcp 的 keepalive : tcp 层,内核态实现,称为 tcp 保活机制,没有数据时发送探测报文判断连接是否存活,需要 socket 接口设置 SO_KEEPALIVE 才能生效")])]),t._v(" "),a("h2",{attrs:{id:"tcp-调优"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-调优"}},[t._v("#")]),t._v(" tcp 调优")]),t._v(" "),a("h3",{attrs:{id:"三次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),a("h4",{attrs:{id:"客户端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#客户端"}},[t._v("#")]),t._v(" 客户端")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("参数")]),t._v(" "),a("th",[t._v("含义")]),t._v(" "),a("th",[t._v("默认")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("/proc/sys/net/ipv4/tcp_syn_resries")]),t._v(" "),a("td",[t._v("syn 包重传次数(每次重传超时时间是上次 2 倍, 1, 2, 4, 8, 16),大概 1 分钟会终止握手")]),t._v(" "),a("td",[t._v("5")])])])]),t._v(" "),a("h3",{attrs:{id:"服务端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务端"}},[t._v("#")]),t._v(" 服务端")]),t._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("netstat")]),t._v(" -s "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("grep")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"SYNs to LISTEN"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 半连接队列满引发的重试次数,表示有多少个 tcp 连接因为半连接队列满而被丢弃")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("table",[a("thead",[a("tr",[a("th",[t._v("参数")]),t._v(" "),a("th",[t._v("含义")]),t._v(" "),a("th",[t._v("默认")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("/proc/sys/net/ipv4/tcp_max_syn_backlog")]),t._v(" "),a("td",[t._v("半连接队列长度(需要同时增加 accept 才生效)")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("/proc/sys/net/ipv4/somaxconn")]),t._v(" "),a("td",[t._v("accept 队列长度")]),t._v(" "),a("td",[t._v("128")])]),t._v(" "),a("tr",[a("td",[t._v("backclog(web 服务器参数,即 listen 参数)")]),t._v(" "),a("td",[t._v("listen( int sockfd, int backlog)")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("/proc/sys/net/ipv4/tcp_synack_retries")]),t._v(" "),a("td",[t._v("syn + ack 重试次数")]),t._v(" "),a("td",[t._v("5")])])])]),t._v(" "),a("p",[t._v("accept 队列长度 min(somaxconn, backlog)")]),t._v(" "),a("p",[t._v("开启 synccookies 可以在半连接队列满后不丢弃连接,可以不使用半连接队列建立连接.")]),t._v(" "),a("h5",{attrs:{id:"半连接队列满了必须要丢弃吗-synccookies"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#半连接队列满了必须要丢弃吗-synccookies"}},[t._v("#")]),t._v(" 半连接队列满了必须要丢弃吗? synccookies")]),t._v(" "),a("p",[t._v("服务器根据当前状态计算一个值,放在 syn + ack 的报文中,当客户端返回 ack 时取出该值验证,如果合法就可以成功建立连接.")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("/proc/sys/net/ipv4/tcp_syncookies")]),t._v(" "),a("th",[t._v("含义")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("0")]),t._v(" "),a("td",[t._v("关闭该功能")])]),t._v(" "),a("tr",[a("td",[t._v("1")]),t._v(" "),a("td",[t._v("仅当 syn 半连接队列满时再启用")])]),t._v(" "),a("tr",[a("td",[t._v("2")]),t._v(" "),a("td",[t._v("无条件开启")])])])]),t._v(" "),a("h5",{attrs:{id:"accept-队列满了必须丢弃吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#accept-队列满了必须丢弃吗"}},[t._v("#")]),t._v(" accept 队列满了必须丢弃吗?")]),t._v(" "),a("p",[t._v("默认丢弃,但是可以向客户端发送 RST 报文")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("/proc/sys/net/ipv4/tcp_abort_on_overflow")]),t._v(" "),a("th",[t._v("含义")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("0")]),t._v(" "),a("td",[t._v("如果 accept 队列满了,丢弃 ack")])]),t._v(" "),a("tr",[a("td",[t._v("1")]),t._v(" "),a("td",[t._v("如果 accept 队列满了,发送 RST,废弃当前握手")])])])]),t._v(" "),a("h3",{attrs:{id:"查看半连接和全连接长度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查看半连接和全连接长度"}},[t._v("#")]),t._v(" 查看半连接和全连接长度")]),t._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[t._v("ss -ltn "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# l 显示正在监听的 socket, n 不解析服务名称 t 只显示 tcp")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("date")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("netstat")]),t._v(" -s "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("grep")]),t._v(" overflowed "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 查看 accept 满丢弃的连接数")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("Recv-Q : 当前 accept 队列大小,当前完成三次握手,等待服务器 accept 的 tcp 连接")]),t._v(" "),a("p",[t._v("Send-Q : accept 队列最大长度,")]),t._v(" "),a("h3",{attrs:{id:"tcp-fast-open"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp-fast-open"}},[t._v("#")]),t._v(" TCP Fast Open")]),t._v(" "),a("p",[t._v("需要客户端和服务器同时开启才生效")]),t._v(" "),a("ol",[a("li",[t._v("客户端 syn 时请求 cookie")]),t._v(" "),a("li",[t._v("服务器返回 syn + ack 时携带 cookie")]),t._v(" "),a("li",[t._v("客户端保存 cookie")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("tcp_fastopen")]),t._v(" "),a("th",[t._v("含义")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("0")]),t._v(" "),a("td",[t._v("关闭")])]),t._v(" "),a("tr",[a("td",[t._v("1")]),t._v(" "),a("td",[t._v("作为客户端使用该功能")])]),t._v(" "),a("tr",[a("td",[t._v("2")]),t._v(" "),a("td",[t._v("作为服务器使用该功能")])]),t._v(" "),a("tr",[a("td",[t._v("3")]),t._v(" "),a("td",[t._v("无论客户端和服务器都可以使用")])])])]),t._v(" "),a("h3",{attrs:{id:"四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[t._v("#")]),t._v(" 四次挥手")]),t._v(" "),a("p",[t._v("关闭连接方式有两种, RST 报文和 FIN 报文.如果进程异常退出,内核会发送 RST 报文来关闭.")]),t._v(" "),a("h4",{attrs:{id:"close-shutdown"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#close-shutdown"}},[t._v("#")]),t._v(" close & shutdown")]),t._v(" "),a("p",[t._v("close : 调用 close 表示完全断开连接,不能发送也不能接收调用了 close 函数的一方叫孤儿连接, netstat -p 对应进程名是空的.")]),t._v(" "),a("p",[t._v("shutdown : 可以关闭一个方向的连接.")]),t._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("shundown")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" sock"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" howto"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("table",[a("thead",[a("tr",[a("th",[t._v("参数")]),t._v(" "),a("th",[t._v("含义")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("shut_rd(0)")]),t._v(" "),a("td",[t._v("关闭读,如果接收缓存区已有数据,则丢弃,并且后续收到新数据会 ack,然后悄悄丢弃,对端不知道已丢弃")])]),t._v(" "),a("tr",[a("td",[t._v("shut_wr(1)")]),t._v(" "),a("td",[t._v("关闭写,如果发送缓存区还有未发送数据,则被立即发出,并发送一个 FIN 报文给对方")])]),t._v(" "),a("tr",[a("td",[t._v("shut_rdwr(2)")]),t._v(" "),a("td",[t._v("关闭读写,相对于 shut_rd 和 shut_wr 各执行一次")])])])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("参数")]),t._v(" "),a("th",[t._v("含义")]),t._v(" "),a("th",[t._v("默认")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("tcp_orphan_reties")]),t._v(" "),a("td",[t._v("FIN 报文重拾次数")]),t._v(" "),a("td",[t._v("0(代表 8 次)")])]),t._v(" "),a("tr",[a("td",[t._v("tcp_max_orphan")]),t._v(" "),a("td",[t._v("FIN_Wait_1 最大连接数,如果孤儿连接数量大于它,新的孤儿连接将不走四次挥手,直接 RST 强制关闭")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("tcp_fin_timeout")]),t._v(" "),a("td",[t._v("控制 fin_wait_2 状态连接的持续时间")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("tcp_max_tw_buckets")]),t._v(" "),a("td",[t._v("time_wait 数量超过该参数新关闭的连接不再经历 time_wait 直接关闭")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("tcp_tw_reuse")]),t._v(" "),a("td",[t._v("建立新连接时复用 time_wait 状态的连接,该参数只使用客户端,服务端没有用")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("tcp_tw_recycle")]),t._v(" "),a("td"),t._v(" "),a("td")])])]),t._v(" "),a("h3",{attrs:{id:"fin-无法发送"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fin-无法发送"}},[t._v("#")]),t._v(" fin 无法发送")]),t._v(" "),a("ol",[a("li",[t._v("tcp 报文必须有序,如果发送缓存区有数据, FIN 不能提前发送")]),t._v(" "),a("li",[t._v("tcp 有流量控制功能,如果接收方接收窗口为 0 发送方不能发送数据,攻击者通过接收窗口设置 0,会使 FIN 无法发送")])]),t._v(" "),a("ul",[a("li",[t._v("通常对 socket 执行 close 或 shutdown 会发送 fin 包,实际上只要应用退出(kill),都会发送 fin")]),t._v(" "),a("li",[t._v("fin 是不再发送数据,shutdown 关闭读不回发送 fin,只有关闭写才会发送")]),t._v(" "),a("li",[t._v("如果机器上有大量 fin-wait-2 需要检查有大量 close_wait 机器为什么不调用 close 关闭连接")])]),t._v(" "),a("p",[t._v("全双工 : 发送数据的同时可以接收数据")]),t._v(" "),a("p",[t._v("程序主动调用 close 如果 socket 接受缓存区有数据,会发送 RST,如果发送缓存区有数据会等发送完,发送 Fin.")]),t._v(" "),a("h2",{attrs:{id:"time-wait-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#time-wait-2"}},[t._v("#")]),t._v(" time_wait")]),t._v(" "),a("ol",[a("li",[t._v("防止收到历史数据,导致数据错乱,time_wait 足以让两个方向的数据丢弃,使原来连接的数据包在网络中消失.再出现的数据包一定是新建立的连接产生的")]),t._v(" "),a("li",[t._v("保证连接正常关闭 : 等待足够时间却确保最后的 ack 被对方收到,使其正常关闭")])]),t._v(" "),a("h2",{attrs:{id:"_0-0-0-0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_0-0-0-0"}},[t._v("#")]),t._v(" 0.0.0.0")]),t._v(" "),a("p",[t._v("表示本机上所有 ipv4 地址,即所有网卡地址.")]),t._v(" "),a("p",[t._v("ping 127.0.0.1 和本机 ip 都是走回环网卡,将数据插入一个所有网卡共用的链表,产生软中断通知 ksofttirqd 进行收数据.")])])}),[],!1,null,null,null);_.default=s.exports}}]);