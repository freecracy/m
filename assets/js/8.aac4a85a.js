(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{493:function(_,v,t){_.exports=t.p+"assets/img/jinchengzhuangtai.d0a4811b.png"},494:function(_,v,t){_.exports=t.p+"assets/img/jinchenglianbiao.616cf692.png"},495:function(_,v,t){_.exports=t.p+"assets/img/jinchengshangxiawenqiehuan.4d39f8d3.png"},496:function(_,v,t){_.exports=t.p+"assets/img/jinchengIPC.43c998e3.png"},497:function(_,v,t){_.exports=t.p+"assets/img/duojifankui.97b30ea7.png"},524:function(_,v,t){"use strict";t.r(v);var a=t(20),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h1",{attrs:{id:"进程线程协程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程线程协程"}},[_._v("#")]),_._v(" 进程线程协程")]),_._v(" "),a("h2",{attrs:{id:"进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程"}},[_._v("#")]),_._v(" 进程")]),_._v(" "),a("p",[_._v("操作系统资源管理的最小单元,在操作系统中是用进程控制块(PCB)数据结构来描述进程但,PCB是进程存在的唯一标识,进程消失PCB也就消失了,当进程读取发生IO时cpu会切换其他进程,当IO操作完成后给cpu发送中断信号于是进程恢复调度.")]),_._v(" "),a("h3",{attrs:{id:"pcb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pcb"}},[_._v("#")]),_._v(" PCB")]),_._v(" "),a("table",[a("thead",[a("tr",[a("th",[_._v("信息")]),_._v(" "),a("th",[_._v("作用")])])]),_._v(" "),a("tbody",[a("tr",[a("td",[_._v("进程描述信息")]),_._v(" "),a("td",[_._v("进程标识符、用户标识符(主要为共享和保护服务)")])]),_._v(" "),a("tr",[a("td",[_._v("进程控制管理信息")]),_._v(" "),a("td",[_._v("进程当前状态、进程优先级")])]),_._v(" "),a("tr",[a("td",[_._v("资源分配清单")]),_._v(" "),a("td",[_._v("内存地址空间、虚拟地址空间、所打开的文件列表、IO设备信息")])]),_._v(" "),a("tr",[a("td",[_._v("CPU相关")]),_._v(" "),a("td",[_._v("CPU各个寄存器的值,进程被切换时CPU状态信息就会保存在PCB中")])])])]),_._v(" "),a("h3",{attrs:{id:"进程状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程状态"}},[_._v("#")]),_._v(" 进程状态")]),_._v(" "),a("p",[a("img",{attrs:{src:t(493),alt:"jinchengzhuangtai"}})]),_._v(" "),a("p",[_._v("进程状态包括运行、就绪、阻塞(即使给CPU控制权也无法运行)、创建、结束、挂起(表示没有占用内存空间)")]),_._v(" "),a("p",[_._v("阻塞挂起 : 进程在外存,并等待某个事件出现")]),_._v(" "),a("p",[_._v("就绪挂起 : 进程在外存,但只要进入内存就立刻运行")]),_._v(" "),a("h3",{attrs:{id:"进程管理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程管理"}},[_._v("#")]),_._v(" 进程管理")]),_._v(" "),a("p",[_._v("链表或索引(将同一状态的进程组织在一个索引表中,不同状态指向不同索引表)")]),_._v(" "),a("p",[a("img",{attrs:{src:t(494),alt:"jinchenglianbiao"}})]),_._v(" "),a("h3",{attrs:{id:"进程创建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程创建"}},[_._v("#")]),_._v(" 进程创建")]),_._v(" "),a("p",[_._v("操作系统允许一个进程创建另一个进程允许子进程继承父进程拥有的资源.子进程退出在父进程继承的资源要归还父进程终止父进程时同时终止所有子进程.")]),_._v(" "),a("ol",[a("li",[_._v("为新进程分配唯一进程标识符,并申请一个空白pcb,pcb有限,如果申请失败则创建失败.")]),_._v(" "),a("li",[_._v("为进程分配资源,如果资源不足,进程就会进入等待状态")]),_._v(" "),a("li",[_._v("初始化pcb")]),_._v(" "),a("li",[_._v("如果进程调度队列有空闲空间,将进程插入到就绪队列等待调度")])]),_._v(" "),a("h3",{attrs:{id:"进程终止"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程终止"}},[_._v("#")]),_._v(" 进程终止")]),_._v(" "),a("p",[_._v("正常结束、异常结束、外界干预(kill + 信号量)")]),_._v(" "),a("ol",[a("li",[_._v("查找需要终止的进程PCB")]),_._v(" "),a("li",[_._v("如果处于执行状态,立即终止执行,将cpu资源分配给其他进程")]),_._v(" "),a("li",[_._v("如果还有子进程将所有子进程终止")]),_._v(" "),a("li",[_._v("将资源归还给父进程或操作系统")]),_._v(" "),a("li",[_._v("将其从PCB所在队列中删除")])]),_._v(" "),a("h3",{attrs:{id:"阻塞进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#阻塞进程"}},[_._v("#")]),_._v(" 阻塞进程")]),_._v(" "),a("p",[_._v("当进程等待某事件完成时调用阻塞语句把自己阻塞,一旦阻塞等待只能由另一个进程唤醒")]),_._v(" "),a("ol",[a("li",[_._v("找到进程标识符对应的PCB")]),_._v(" "),a("li",[_._v("如果为运行态,保护现场将其转换为阻塞状态停止运行")]),_._v(" "),a("li",[_._v("将PCB插入到阻塞队列中去")])]),_._v(" "),a("h3",{attrs:{id:"唤醒进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#唤醒进程"}},[_._v("#")]),_._v(" 唤醒进程")]),_._v(" "),a("p",[_._v("阻塞状态到进程不可以自己唤醒自己.如果某进程正在等待io事件,当进程所期待的io事件出现时才有发起者进程用唤醒语句唤醒它.阻塞和唤醒同时出现,某个进程调用阻塞语句,必有一个与之对应的唤醒语句.")]),_._v(" "),a("ol",[a("li",[_._v("在该事件的阻塞队列中找到进程的PCB")]),_._v(" "),a("li",[_._v("从阻塞队列移除,将状态改为就绪状态")]),_._v(" "),a("li",[_._v("把PCB插入到就绪队列中,等待调度程序调度")])]),_._v(" "),a("h3",{attrs:{id:"进程上下文切换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程上下文切换"}},[_._v("#")]),_._v(" 进程上下文切换")]),_._v(" "),a("h4",{attrs:{id:"cpu上下文切换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cpu上下文切换"}},[_._v("#")]),_._v(" cpu上下文切换")]),_._v(" "),a("p",[_._v("cpu上下文 : cpu寄存器和程序计数器是运行任何任务前必须依赖的环境这些环境就叫做cpu上下文.")]),_._v(" "),a("p",[_._v("上下文切换就是把前一个任务的上下文保存起来然后加载新任务的上下文到寄存器和计数器最后跳到程序计数器指向的新位置运行,这里的任务分为进程、线程、中断.所以cpu上下文切换分为进程上下文切换、线程上下文切换、终端上下文切换.")]),_._v(" "),a("p",[_._v("进程由内核管理和调度所以进程切换只能发生在内核态.进程上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源,还包含内核堆栈、寄存器等内核空间的资源.通常把交换的信息保存在进程的pcb中,当运行另外一个进程的时候,需要从这个进程的pcb中取出上下文,然后恢复到cpu中,使进程可以继续执行.进程上下文开销使很大的,希望上下文切换开销越小越好.")]),_._v(" "),a("p",[a("img",{attrs:{src:t(495),alt:"jinchengshangxiawenqiehuan"}})]),_._v(" "),a("ol",[a("li",[_._v("时间片耗尽 : 某个进程时间片耗尽就会被系统挂起切换到其他就绪进程")]),_._v(" "),a("li",[_._v("系统资源不足 : 需要等待资源满足后才可运行,这时也会被挂起,由系统调度其他进程运行")]),_._v(" "),a("li",[_._v("sleep 函数 : 通过 sleep 函数主动让出cpu")]),_._v(" "),a("li",[_._v("优先级 : 当有优先级更高的进程运行时当前进程会被挂起")]),_._v(" "),a("li",[_._v("发生硬件中断 : cpu上的进程会被中断挂起,转而执行内核中的中断服务程序")])]),_._v(" "),a("h3",{attrs:{id:"进程间通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程间通信"}},[_._v("#")]),_._v(" 进程间通信")]),_._v(" "),a("p",[a("img",{attrs:{src:t(496),alt:"jinchengIPC"}})]),_._v(" "),a("ol",[a("li",[_._v("信号 signal : 进程可以选择忽略信号但是 SIGSTOP 和 SIGKILL 不可忽略,如果该进程不是执行态,内核会暂时保存信号当进程恢复执行后传递.信号在用户空间进程和内核之间直接交互,内核可以利用信号通知用户空间信号进程发生了哪些系统事件.")]),_._v(" "),a("li",[_._v("管道 : "),a("code",[_._v("|")]),_._v("单向通道,两个进程间建立通道,一个向通道中写入字节流,另一个从管道中读取字节流,管道是同步的,当从空的管道读取数据时会被阻塞,实质是一个内核缓存区,以 FIFO 的方式从缓存区存取数据数据只能单向流动,而且只能是父子进程间的通信,管道的一端顺序写入,另一端顺序读取,可以看作循环队列一个数据只能读取一次,读完后就会删除,当缓存区读空或写满,读数据进程或写数据进程进入等待队列.空缓存区有新数据写入或满缓存区有数据读取时唤醒等待队列中的进程.是个特殊的文件,不过只存在内存不存在文件系统中.管道创建的两个文件描述符存在进程内需要通过 fork 与子进程共享.本质是通过 fork 来复制进程 fd 文件描述符来通信.")]),_._v(" "),a("li",[_._v("共享内存 : shmget(创建共享内存或使用已创建的内存段)、shmat(将进程附加到已创建的内存段)、shmdt(从已连接的共享内存段分离进程)、shmctl(对共享内存段执行控制操作),一个进程吧地址空间的一段映射到能被其他进程所访问的内存,一个进程创建,多个进程可访问进程可以直接读写而不需要数据拷贝是最快的 IPC 形式,针对其他形式效率低设计的共享内存通常和其它机制配合使用,如信号量配合实现进程同步和互斥通信.共享内存解决内核空间和用户空间拷贝数据问题.进程使用的是虚拟内存,两个进程拿出一块虚拟地址映射到相同的物理内存中.一个进程写入另一个进程就可以读区,不需要内核态和用户态拷贝.单存在同时写入问题.信号量,整型计数器,用于实现进程间互斥与同步,解决共享内存同时写入问题.控制信号量通过 p 和 v 操作,p 操作将信号量 -1,如果 <0 则资源被占用需要阻塞等待, v 操作把信号量 +1,如果 <=0 表示有阻塞进程会将阻塞进程唤醒, p 操作用在进入共享资源前, v 操作用在离开共享资源后,")]),_._v(" "),a("li",[_._v("先进先出队列(命名管道) : 未命名管道没有备份文件,操作系统维护内存缓存区将字节从写入器传到读取器,一旦写入或输出终止,缓存区将被收回,数据丢失,命名管道以文件存在,通信完成后将保留在文件系统中,非命名管道只能在父子进程间通信,有名管道提供一个路径名,以文件形式存在于文件系统中,即使不存在亲缘关系也可以访问该路径通信,全双工数据通信.使用前需要 mkfifo 命令来创建并指定管道名字.命名管道类似无缓存 channel 会阻塞命令.")]),_._v(" "),a("li",[_._v("消息队列 : 存放在内核空间并由消息队列标识符标识的只有内核重启或主动删除时该消息队列才会被删除的消息链表.消息队列克服了信号传递信息少,管道只能承载无格式字节流和缓存区大小受限等限制,某个进程网一个消息队列写入消息之前并不需要另外读进程在该队列上等待消息到达.相当于有缓存 channel ,但是每个链表节点固定大小限制.不适合比较大的数据传输.存在内核态和用户态拷贝数据开销.进程写入内核中消息队列时会从用户空间拷贝数据到内核空间,另一个进程读取时需要将数据从内核空间拷贝到用户空间.")]),_._v(" "),a("li",[_._v("socket : TCP/IP 协议是建立在 socket 通信之上可以本机进程通信,也可以跨网通信通过网络接口将数据发送到本地不同进程或远程进程.")])]),_._v(" "),a("h3",{attrs:{id:"socket"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#socket"}},[_._v("#")]),_._v(" socket")]),_._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("int")]),_._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[_._v("socket")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("int")]),_._v(" domain"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("int")]),_._v(" type"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("int")]),_._v(" protocal"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n")])]),_._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[_._v("1")]),a("br")])]),a("table",[a("thead",[a("tr",[a("th",[_._v("函数")]),_._v(" "),a("th",[_._v("作用")])])]),_._v(" "),a("tbody",[a("tr",[a("td",[_._v("bind")]),_._v(" "),a("td",[_._v("本地字节流和本地数据报绑定一个本地文件,TCP和UDP绑定IP和端口")])]),_._v(" "),a("tr",[a("td",[_._v("listen")]),_._v(" "),a("td",[_._v("UDP 不要要")])]),_._v(" "),a("tr",[a("td",[_._v("accept")]),_._v(" "),a("td")]),_._v(" "),a("tr",[a("td",[_._v("connect")]),_._v(" "),a("td",[_._v("UDP 不需要")])]),_._v(" "),a("tr",[a("td",[_._v("read")]),_._v(" "),a("td")]),_._v(" "),a("tr",[a("td",[_._v("write")]),_._v(" "),a("td")]),_._v(" "),a("tr",[a("td",[_._v("close")]),_._v(" "),a("td")]),_._v(" "),a("tr",[a("td",[_._v("sendto")]),_._v(" "),a("td",[_._v("UDP 中的发送")])]),_._v(" "),a("tr",[a("td",[_._v("recvfrom")]),_._v(" "),a("td",[_._v("UDP 中的接收")])]),_._v(" "),a("tr",[a("td",[_._v("showdown")]),_._v(" "),a("td")])])]),_._v(" "),a("h4",{attrs:{id:"tcp字节流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tcp字节流"}},[_._v("#")]),_._v(" TCP字节流")]),_._v(" "),a("p",[_._v("socket 类型 AF_INET 和 SOCK_STREAM")]),_._v(" "),a("h4",{attrs:{id:"udp字节流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#udp字节流"}},[_._v("#")]),_._v(" UDP字节流")]),_._v(" "),a("p",[_._v("socket 类型 AF_INET 和 SOCK_DGRAM")]),_._v(" "),a("h4",{attrs:{id:"本地进程通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本地进程通信"}},[_._v("#")]),_._v(" 本地进程通信")]),_._v(" "),a("p",[_._v("本地字节流 : 类型 AF_LOCAL 和 SOCK_STREAM")]),_._v(" "),a("p",[_._v("本地数据报 : 类型 AF_LOCAL 和 SOCK_DGRAM")]),_._v(" "),a("h4",{attrs:{id:"常用信号"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用信号"}},[_._v("#")]),_._v(" 常用信号")]),_._v(" "),a("h2",{attrs:{id:"线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[_._v("#")]),_._v(" 线程")]),_._v(" "),a("p",[_._v("被调度的最小单元,被包含在进程中,进程中实际运行单元.线程切换比进程切换时保存的信息要少很多,线程使进程中的一条执行流程,可以并发运行的同时共享地址空间,同一个进程内多个线程之间可以共享代码段、数据端、打开的文件列表,但每个线程都有独立的寄存器和栈,")]),_._v(" "),a("ol",[a("li",[_._v("进程是资源分配单位,线程是cpu调度单位")]),_._v(" "),a("li",[_._v("进程拥有完整的资源,线程独享必不可少资源(寄存器和栈)")]),_._v(" "),a("li",[_._v("都有运行、阻塞、执行等状态和转换")])]),_._v(" "),a("p",[_._v("多线程同步是线程间的一种制约关系,一个线程的执行依赖另一个线程的通知,当没有得到另一个线程通知时必须等待直到消息到达时才被唤醒,有很强的先后执行关系.")]),_._v(" "),a("p",[_._v("多线程互斥指多个线程访问资源多排它性,多个线程是有共享资源时同一时刻只能被一个线程占有,其它线程必须等待,知道占用资源的线程释放.")]),_._v(" "),a("p",[_._v("cpu 亲和性时绑定一个进程或线程到指定 cpu 或 cpu 集合,使该进程或线程只能被调度运行在绑定的 cpu 或 cpu 集合上,进程的上一次运行上下文会保存在 cpu 缓存中如果仍然调度到同一 cpu 避免缓存未命中")]),_._v(" "),a("h3",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[_._v("#")]),_._v(" 优点")]),_._v(" "),a("ol",[a("li",[_._v("一个进程可以同时存在多个线程")]),_._v(" "),a("li",[_._v("各个线程可以并发执行")]),_._v(" "),a("li",[_._v("各个线程之间可以共享地址空间和文件资源等")])]),_._v(" "),a("h3",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[_._v("#")]),_._v(" 缺点")]),_._v(" "),a("p",[_._v("进程中一个线程崩溃时会导致所属进程的所有线程崩溃")]),_._v(" "),a("h3",{attrs:{id:"线程为什么可以减少资源开销"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程为什么可以减少资源开销"}},[_._v("#")]),_._v(" 线程为什么可以减少资源开销")]),_._v(" "),a("p",[_._v("线程切换比进程切换时间效率和空间效率都很高.")]),_._v(" "),a("ol",[a("li",[_._v("线程创建时间比较快,因为进程创建时还需要资源管理信息,比如内存管理、文件管理而线程创建过程中不涉及资源管理而是共享他们")]),_._v(" "),a("li",[_._v("线程终止时间比进程快,线程释放的资源比进程少很多")]),_._v(" "),a("li",[_._v("同一个进程内线程切换比较快,因为线程拥有相同的地址空间(虚拟内存共享),同一个进程中的线程具有同一个页表切换时不需要切换也表,而对于进程的切换需要把也表切换掉而页表切换开销是非常大的")]),_._v(" "),a("li",[_._v("同一个进程的各个线程之间共享内存和文件资源那么线程之间数据传递就不需要经过内核使得线程间数据交换更高效")])]),_._v(" "),a("h3",{attrs:{id:"线程的上下文切换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程的上下文切换"}},[_._v("#")]),_._v(" 线程的上下文切换")]),_._v(" "),a("p",[_._v("线程是调度的基本单位,进程是资源分配的基本单位.操作系统的任务调度实际调度对象是线程,进程只给线程提供了虚拟内存、全局变量、文件列表等资源.")]),_._v(" "),a("ol",[a("li",[_._v("两个线程不是同一个进程,切换过程和进程上下文切换一样")]),_._v(" "),a("li",[_._v("同一个进程内的线程切换只需要切换线程的私有数据(栈)和寄存器等不共享数据")])]),_._v(" "),a("h3",{attrs:{id:"三种实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三种实现"}},[_._v("#")]),_._v(" 三种实现")]),_._v(" "),a("ol",[a("li",[_._v("用户线程 : 哎用户空间实现的线程,不由内核管理,由用户态线程库来完成线程的管理")]),_._v(" "),a("li",[_._v("内核线程 : 在内核中实现等线程,由内核管理等线程")]),_._v(" "),a("li",[_._v("轻量级进程 : 在内核中支持用户线程")])]),_._v(" "),a("h3",{attrs:{id:"用户线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#用户线程"}},[_._v("#")]),_._v(" 用户线程")]),_._v(" "),a("p",[_._v("用户态线程基于用户态线程管理库实现,操作系统看不到线程控制块(TCB),只能看到进程控制块(PCB),用户态线程的管理和调度操作系统是不直接参与的而由用户级线程库函数来完成,包括创建、终止、同步、调度等.用户线程模型类似于多对一关系,多个用户线程对应一个内核线程.")]),_._v(" "),a("p",[_._v("每个进程都有TCB列表用来记录各个线程状态(栈、寄存器)")]),_._v(" "),a("h4",{attrs:{id:"缺点-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[_._v("#")]),_._v(" 缺点")]),_._v(" "),a("ol",[a("li",[_._v("操作系统不参与调度,一个因系统调度而阻塞,进程包含的所有用户线程都阻塞")]),_._v(" "),a("li",[_._v("一个线程开始运行除非主动交出cpu使用权否则所在进程中的其它线程无法运行,因为用户态线程无法打断当前运行中的线程它没有这个特权只有操作系统由,但用户线程不由操作系统管理")]),_._v(" "),a("li",[_._v("时间片是分给进程的,多线程执行时每个线程得到的时间片很少,执行比较慢")])]),_._v(" "),a("h3",{attrs:{id:"内核线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内核线程"}},[_._v("#")]),_._v(" 内核线程")]),_._v(" "),a("p",[_._v("内核线程由操作系统管理,线程对应的TCB放在操作系统里,线程创建、终止、管理都由操作系统负责,内核线程模型类似一对一关系一个用户线程对应一个内核线程")]),_._v(" "),a("ol",[a("li",[_._v("某个内核线程因系统调度而阻塞,并不影响其他内核线程运行")]),_._v(" "),a("li",[_._v("创建、终止、调度都由操作系统管理,开销大")])]),_._v(" "),a("h3",{attrs:{id:"轻量级线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#轻量级线程"}},[_._v("#")]),_._v(" 轻量级线程")]),_._v(" "),a("h3",{attrs:{id:"调度算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调度算法"}},[_._v("#")]),_._v(" 调度算法")]),_._v(" "),a("ol",[a("li",[_._v("非抢占式调度 : 挑选一个进程让该进程运行直到被阻塞或结束退出才会调度另一个进程,不理会时钟中断")]),_._v(" "),a("li",[_._v("抢占式调度 : 挑选一个进程,让进程只运行某段时间,如果时间结束,该进程仍在运行则挂起,然后从就绪队列挑选另外一个进程,需要在时间间隔的末端发生时钟中断,把cpu控制权交给调度程序,也称时间片机制")])]),_._v(" "),a("table",[a("thead",[a("tr",[a("th",[_._v("调度算法")]),_._v(" "),a("th",[_._v("简介")]),_._v(" "),a("th",[_._v("缺点")])])]),_._v(" "),a("tbody",[a("tr",[a("td",[_._v("先来先服务")]),_._v(" "),a("td",[_._v("每次从就绪队列中选择最先进入队列的进程")]),_._v(" "),a("td",[_._v("长作业先运行了短作业等待时间就会过长,对长作业有利")])]),_._v(" "),a("tr",[a("td",[_._v("最短作业优先调度")]),_._v(" "),a("td",[_._v("优先选择运行时间最短的进程运行")]),_._v(" "),a("td",[_._v("长作业一直后推无法执行")])]),_._v(" "),a("tr",[a("td",[_._v("高响应比优先")]),_._v(" "),a("td",[_._v("计算响应优先级,响应优先级最高的进入调度")]),_._v(" "),a("td",[_._v("权衡短作业和长作业")])]),_._v(" "),a("tr",[a("td",[_._v("时间片轮转")]),_._v(" "),a("td"),_._v(" "),a("td")]),_._v(" "),a("tr",[a("td",[_._v("最高优先级调度")]),_._v(" "),a("td",[_._v("选择高优先级调度")]),_._v(" "),a("td")]),_._v(" "),a("tr",[a("td",[_._v("多级反馈队列调度")]),_._v(" "),a("td",[_._v("时间片轮转和最高优先级的综合")]),_._v(" "),a("td")])])]),_._v(" "),a("blockquote",[a("p",[_._v("优先权 = (等待时间+要求服务时间) / 要求服务时间")])]),_._v(" "),a("p",[_._v("静态优先级 : 创建过程中确定,不可修改")]),_._v(" "),a("p",[_._v("动态优先级 : 动态调整,运行时间增加,降低优先级,等待时间长则增加优先级")]),_._v(" "),a("p",[_._v("多级 : 表示有多个队列,每个队列优先级由高到低,优先级越高时间片越短")]),_._v(" "),a("p",[_._v("反馈 : 新的进程加入优先级高的队列立刻停止当前运行的进程,转而运行优先级高的队列")]),_._v(" "),a("p",[a("img",{attrs:{src:t(497),alt:"duojifankui"}})]),_._v(" "),a("ol",[a("li",[_._v("设置多个队列,每个队列不同优先级,优先级越高时间片越短")]),_._v(" "),a("li",[_._v("新进程会放入第一级队列的末尾,按先来先服务等待被调度,如果第一级队列规定的时间片没有运行完成则转入第二级队列末尾,依次类推直到完成")]),_._v(" "),a("li",[_._v("当较高优先级队列空才调度低优先级队列中的进程运行,运行时有新进程进入高优先级队列则停止当前运行的进程放入原队列末尾,让优先级较高的进程运行")])]),_._v(" "),a("h3",{attrs:{id:"调度原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#调度原则"}},[_._v("#")]),_._v(" 调度原则")]),_._v(" "),a("ol",[a("li",[_._v("运行时发生io请求,cpu空闲,切换其他进程")]),_._v(" "),a("li",[_._v("运行时间过长,长时间占用cpu,系统切换出去,运行其他进程")]),_._v(" "),a("li",[_._v("从进程开始到结束包含运行时间和等待时间这两个时间和是周转时间,调度程序应避免等待时间长运行时间短")])]),_._v(" "),a("h3",{attrs:{id:"线程创建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#线程创建"}},[_._v("#")]),_._v(" 线程创建")]),_._v(" "),a("p",[_._v("通过 "),a("code",[_._v("kernel_thread")]),_._v("函数调用"),a("code",[_._v("do_fork")]),_._v("根据 clone_flag 标志来调用 clone 来创建线程.")]),_._v(" "),a("h2",{attrs:{id:"协程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协程"}},[_._v("#")]),_._v(" 协程")]),_._v(" "),a("h2",{attrs:{id:"死锁检测器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死锁检测器"}},[_._v("#")]),_._v(" 死锁检测器")]),_._v(" "),a("p",[_._v("死锁检测器对应用程序创建的线程进行分析,如果创建并处于活跃的线程数大于空闲线程数,则会出现死锁.在检测到死锁时.")]),_._v(" "),a("h2",{attrs:{id:"同步-异步-阻塞-非阻塞"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步-异步-阻塞-非阻塞"}},[_._v("#")]),_._v(" 同步 & 异步 & 阻塞 & 非阻塞")]),_._v(" "),a("p",[_._v("同步是并发进程、线程、协程在一个关键点上需要互相等待与互通消息,这种相互制约的等待与互通信息称为进程、线程、协程同步.同步关注的是语句的执行顺序,如果上一个语句必须执行完才能执行下一个语句就是同步,如果不是就是异步,阻塞是关注的是 cpu 是否在 io 期间干等着,如果 io 期间可以做其他的事就是非阻塞的,不能动就是阻塞.")]),_._v(" "),a("h2",{attrs:{id:"同步互斥"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步互斥"}},[_._v("#")]),_._v(" 同步互斥")]),_._v(" "),a("h3",{attrs:{id:"锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[_._v("#")]),_._v(" 锁")]),_._v(" "),a("p",[_._v("使用加锁和解锁操作可以解决进程、线程互斥问题任何想进入临界区的线程必须先进行加锁操作,离开时解锁.")]),_._v(" "),a("ol",[a("li",[_._v("忙等待锁 : 获取不到锁时 while 循环等待,又称自旋锁.")]),_._v(" "),a("li",[_._v("无等待锁 : 获取不到锁时就把当前线程放入锁等待队列,然后执行调度程序,把 cpu 让给调度程序")])]),_._v(" "),a("h3",{attrs:{id:"信号量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#信号量"}},[_._v("#")]),_._v(" 信号量")]),_._v(" "),a("p",[_._v("pv操作,p 操作用在进入临界区前, v 操作是用在离开临界区之后,必须成对出现.")]),_._v(" "),a("ol",[a("li",[_._v("互斥信号量为 1 , 表示咩有线程进入临界区")]),_._v(" "),a("li",[_._v("互斥信号量为 0 , 表示有一个线程进入临界区")]),_._v(" "),a("li",[_._v("互斥信号量为 -1, 表示一个进入临界区,一个等待进入")])]),_._v(" "),a("h2",{attrs:{id:"为什么协程切换比线程快"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么协程切换比线程快"}},[_._v("#")]),_._v(" 为什么协程切换比线程快")]),_._v(" "),a("ol",[a("li",[_._v("协程切换完全在用户态进行")]),_._v(" "),a("li",[_._v("协程切换比线程保存的东西要少")]),_._v(" "),a("li",[_._v("io 阻塞, 不涉及系统调用和阻塞调用")]),_._v(" "),a("li",[_._v("多线程需要额外的同步和通知工作,线程频繁的在阻塞和唤醒间切换")]),_._v(" "),a("li",[_._v("不存在写变量冲突,不需要互斥锁、信号量等同步原语")]),_._v(" "),a("li",[_._v("协程通过代码来完成上下文切换")])]),_._v(" "),a("h3",{attrs:{id:"task-struct"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#task-struct"}},[_._v("#")]),_._v(" task_struct")]),_._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[_._v("// include/linux/sched.h")]),_._v("\n")])]),_._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[_._v("1")]),a("br")])]),a("h2",{attrs:{id:"热重启"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#热重启"}},[_._v("#")]),_._v(" 热重启")]),_._v(" "),a("ol",[a("li",[_._v("父进程先 fork 一个子进程代替自己的工作")]),_._v(" "),a("li",[_._v("子进程就绪后通知父进程正常接受新请求、处理连接上收到的请求")]),_._v(" "),a("li",[_._v("父进程处理完已建立连接上的请求、连接空闲后平滑退出")])]),_._v(" "),a("p",[_._v("线程是操作系统抽象出来的执行流,由操作系统统一调度管理,在一个线程中同样可以抽象出多个执行流,由线程来统一调度管理,协程可以理解为线程之上抽象出来的执行流.操作系统一般通过时钟中断和系统调用进入内核来剥夺线程执行权,属于抢占式调度.协程需要相互配合主动交出执行权.如遇到阻塞文件 Read/Write、Sleep 调度器会介入,执行调度管理.")])])}),[],!1,null,null,null);v.default=s.exports}}]);