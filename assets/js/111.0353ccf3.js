(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{650:function(e,t,a){"use strict";a.r(t);var v=a(20),r=Object(v.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"缓存策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存策略"}},[e._v("#")]),e._v(" 缓存策略")]),e._v(" "),a("h2",{attrs:{id:"旁路缓存-经典方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#旁路缓存-经典方式"}},[e._v("#")]),e._v(" 旁路缓存(经典方式)")]),e._v(" "),a("ul",[a("li",[e._v("读 : 先读取缓存,缓存中没有数据去数据库读取,然后再存入缓存,同时返回相应")]),e._v(" "),a("li",[e._v("写 : 先更新数据库,然后删除缓存")])]),e._v(" "),a("blockquote",[a("p",[e._v("非更新缓存 : 频繁更新浪费资源、缓存数据计算复杂、")])]),e._v(" "),a("h3",{attrs:{id:"问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[e._v("#")]),e._v(" 问题")]),e._v(" "),a("p",[e._v("如果数据更新成功,删除缓存失败.导致数据库中数据是最新的,但缓存中却依然存着旧数据,这时如果读请求过来,就会直接读取缓存中的旧数据.")]),e._v(" "),a("h2",{attrs:{id:"双写一致"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双写一致"}},[e._v("#")]),e._v(" 双写一致")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("先删除缓存,再更新数据库 : 旁路缓存问题原因是删除缓存失败,我们现在确保缓存删除成功,再去更新数据库.如果数据库更新失败了,有读请求过来,就会去数据库读取数据更新到缓存中.不会出现不一致.")]),e._v(" "),a("p",[e._v("解决问题 : 解决缓存删除失败导致数据不一致问题,适用并发不高的场景")])]),e._v(" "),a("li",[a("p",[e._v("缓存延时双删 : 写请求过来先删除缓存,等数据更新成功了,异步等待一段时间再次把缓存删除.读取速度快,会出现短时间内数据不一致.")]),e._v(" "),a("p",[e._v("解决问题 : 解决高并发情况下同时有读请求与写请求不一致问题.一个读请求,一个写请求,如果写删除缓存,然后去数据库更新,读请求发现没数据,请求数据库,写入缓存.如果写请求没有成功,读请求拿到未修改的数据写入缓存,过一会写请求成功了,就会出现缓存与数据库数据不一致了.")])])]),e._v(" "),a("h2",{attrs:{id:"大-key-热-key-发现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#大-key-热-key-发现"}},[e._v("#")]),e._v(" 大 key & 热 key 发现")]),e._v(" "),a("h3",{attrs:{id:"使用-redis-内置功能找出大-key-和热-key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-redis-内置功能找出大-key-和热-key"}},[e._v("#")]),e._v(" 使用 redis 内置功能找出大 key 和热 key")]),e._v(" "),a("ul",[a("li",[e._v("debug object : 阻塞命令,会阻塞其它请求")]),e._v(" "),a("li",[e._v("memory usage : 时间复杂度 O(N),仍有阻塞风险")]),e._v(" "),a("li",[e._v("strlen、hlen、scard、zscard、llen、xlen 等")]),e._v(" "),a("li",[e._v("redis-cli bigkeys : 不可定制")]),e._v(" "),a("li",[e._v("scan + type 配合 cli 结果,实现 key 分析")])]),e._v(" "),a("h3",{attrs:{id:"热-key-发现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#热-key-发现"}},[e._v("#")]),e._v(" 热 key 发现")]),e._v(" "),a("ul",[a("li",[e._v("redis-cli hotkeys : 前提 server maxmemory-policy 为 LFU")]),e._v(" "),a("li",[e._v("通过业务层定位热 key : 业务层记录汇总分析")]),e._v(" "),a("li",[e._v("monitor : 紧急使用,资源消耗太大,不易线上长期使用")]),e._v(" "),a("li",[e._v("redis-rdb-tools(开源工具) : 分析 rdb 实效性较差")])]),e._v(" "),a("h2",{attrs:{id:"大-key-热-key-处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#大-key-热-key-处理"}},[e._v("#")]),e._v(" 大 key 热 key 处理")]),e._v(" "),a("h3",{attrs:{id:"大-key-处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#大-key-处理"}},[e._v("#")]),e._v(" 大 key 处理")]),e._v(" "),a("ul",[a("li",[e._v("对大 key 进行拆分 : 大 key 拆小 key")]),e._v(" "),a("li",[e._v("对大 key 进行清理 : unlink")]),e._v(" "),a("li",[e._v("实时监控内存水位 : 内存使用率,增长率等")]),e._v(" "),a("li",[e._v("对失效数据定时清理")])]),e._v(" "),a("h3",{attrs:{id:"热-key-处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#热-key-处理"}},[e._v("#")]),e._v(" 热 key 处理")]),e._v(" "),a("ul",[a("li",[e._v("在 cluster 中对热 key 复制 : x1、x2、x3 相当于 x 3 个副本,将 key 分散多个 node 解决单一 node 的热 key 压力过大")]),e._v(" "),a("li",[e._v("读写分离 : 增加从节点")]),e._v(" "),a("li",[e._v("热 key 前置 : nginx、或应用层、cdn 层")])])])}),[],!1,null,null,null);t.default=r.exports}}]);