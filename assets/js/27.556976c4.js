(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{421:function(t,a,s){t.exports=s.p+"assets/img/nginxio.2243cb4a.png"},422:function(t,a,s){t.exports=s.p+"assets/img/epoll.55905184.png"},616:function(t,a,s){"use strict";s.r(a);var e=s(20),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"io模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#io模型"}},[t._v("#")]),t._v(" IO模型")]),t._v(" "),e("h2",{attrs:{id:"同步-异步-阻塞-非阻塞"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同步-异步-阻塞-非阻塞"}},[t._v("#")]),t._v(" 同步 & 异步 & 阻塞 & 非阻塞")]),t._v(" "),e("h2",{attrs:{id:"nginx模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nginx模型"}},[t._v("#")]),t._v(" nginx模型")]),t._v(" "),e("p",[e("img",{attrs:{src:s(421),alt:"nginxio"}})]),t._v(" "),e("ol",[e("li",[t._v("事件注册 : 请求到达服务器后先连接到请求服务进程,并注册一个事件,当请求发送数据时就会产生一个读事件此时事件响应进程响应将事件交给进程池处理,同时注册一个写事件,当进程池处理完请求后,会响应写事件,将结果返回给浏览器")]),t._v(" "),e("li",[t._v("事件响应")]),t._v(" "),e("li",[t._v("进程池")])]),t._v(" "),e("h3",{attrs:{id:"sendfile"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sendfile"}},[t._v("#")]),t._v(" sendfile")]),t._v(" "),e("p",[t._v("linux 提供 sendfile 系统调用可以将磁盘文件的特定部分直接传送到代表客户端的 socket 文件描述符,加快了静态文件的请求速度,同时减少cpu和内存的开销.")]),t._v(" "),e("div",{staticClass:"language-c line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ssize_t")]),t._v(" sendfile "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" out_fd"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" in_fd"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("off_t")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("offset\n  "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("size_t")]),t._v(" count\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br")])]),e("h3",{attrs:{id:"内存映射"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存映射"}},[t._v("#")]),t._v(" 内存映射")]),t._v(" "),e("p",[t._v("linux 提供一种磁盘的特殊访问方式,可以将内存中某块地址空间和磁盘文件相关联,对这块内存的访问转换为对磁盘的访问.无需使用 read 和 write 等系统调用来访问文件,而是通过 mmap 系统调用来建立内存和磁盘文件的映射.处理大文件时,内存映射会导致较大的内存开销.")]),t._v(" "),e("h3",{attrs:{id:"直接io"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#直接io"}},[t._v("#")]),t._v(" 直接IO")]),t._v(" "),e("p",[t._v("Linux 在 open 系统调用时增加参数 O_DIRECT 即可绕过内核缓存区,直接访问文件.实现直接IO.")]),t._v(" "),e("blockquote",[e("p",[t._v("innodb 配置 my.cnf 分配 raw 分区跳过内核缓存区")])]),t._v(" "),e("h2",{attrs:{id:"reactor"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reactor"}},[t._v("#")]),t._v(" Reactor")]),t._v(" "),e("h2",{attrs:{id:"proactor"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#proactor"}},[t._v("#")]),t._v(" Proactor")]),t._v(" "),e("h2",{attrs:{id:"select"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#select"}},[t._v("#")]),t._v(" select")]),t._v(" "),e("p",[t._v("时间复杂度 O(N),轮询所有流找出能读写的进行操作,同时处理的流越多,轮询时间越长.以文件形式存在,有最大连接数限制.需要一个数组存放 fd,还需要在内核空间和用户空间复制 fd_set.只有 select 函数.")]),t._v(" "),e("div",{staticClass:"language-shell line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("cat")]),t._v(" /proc/sys/fs/file-max "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 需要重新编译内核才能修改")]),t._v("\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("h2",{attrs:{id:"poll"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#poll"}},[t._v("#")]),t._v(" poll")]),t._v(" "),e("p",[t._v("和 select 没有太大差别,将用户传入的数组拷贝到内核空间的链表,没有最大连接数限制.时间复杂度 O(N).同样存在内核空间和用户空间的数据拷贝 poll_fd.只有 poll 函数.")]),t._v(" "),e("h2",{attrs:{id:"epoll"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#epoll"}},[t._v("#")]),t._v(" epoll")]),t._v(" "),e("p",[t._v("io 多路复用,select、poll、epoll等都是同步 io,都需要在读写事件就绪后自己负责读写,读写过程是阻塞的,异步 io 不需要自己读写异步 io 负责把数据从内核态拷贝到用户态.使用 mmap 减少复制开销.连接数上限受机器内存限制. 1G 大概 10w 连接.连接数少活跃数多时 select 和 poll 更高效.")]),t._v(" "),e("p",[t._v("epoll 使用基于事件的就绪通知方式,先通过 "),e("code",[t._v("epoll_ctl")]),t._v("注册每一个文件描述符,一旦某个描述符就绪,内核采用类似 callback 的回调机制,当进程调用"),e("code",[t._v("epoll_wait")]),t._v("时得到通知."),e("code",[t._v("epoll_wait")]),t._v("返回代表就绪描述符数量的值,然后区 epoll 指定的数组中依次取得响应数量的文件描述符即可,这里是用来 mmap(内存映射) 避免文件描述符在系统调用时复制开销.")]),t._v(" "),e("p",[t._v("epolllt : 默认模式,只要这个 fd 还有数据可读可写,每次 epoll_wait 都会返回它的事件提醒用户操作.")]),t._v(" "),e("p",[t._v("epollet : 高速模式,边缘触发,只会提示一次,再有数据流之前不会再提示,无论 fd 是否还有数据可读. read 一个fd时一定要把它的 buffer 读完")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("函数")]),t._v(" "),e("th",[t._v("作用")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("epoll_create")]),t._v(" "),e("td",[t._v("创建一个 epoll 句柄")])]),t._v(" "),e("tr",[e("td",[t._v("epoll_ctl")]),t._v(" "),e("td",[t._v("注册要监听的事件类型")])]),t._v(" "),e("tr",[e("td",[t._v("epoll_wait")]),t._v(" "),e("td",[t._v("等待事件的产生,轮询就绪链表")])])])]),t._v(" "),e("ol",[e("li",[t._v("select 底层采用数组来管理套接字描述符,数量有限, epoll 用数组和链表来管理")]),t._v(" "),e("li",[t._v("select 需要轮询才知道哪个套接字就绪,epoll 可以异步通知")]),t._v(" "),e("li",[t._v("select 需要在用户空间和内核空间拷贝套接字列表,epoll 只在内核空间不需要拷贝")])]),t._v(" "),e("p",[t._v("所有 socket 上都没有数据时挂载到 wq队列,有数据请求时软中断会从 wq 上将进程加入到就绪队列.")]),t._v(" "),e("p",[e("img",{attrs:{src:s(422),alt:"epoll"}})]),t._v(" "),e("h2",{attrs:{id:"同步阻塞"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同步阻塞"}},[t._v("#")]),t._v(" 同步阻塞")]),t._v(" "),e("p",[t._v("阻塞 io 指需要内核 io 操作完成后才返回用户空间执行用户操作.阻塞是用户空间程序的执行状态.")]),t._v(" "),e("p",[t._v("同步 io 是用户空间的线程主动发起 io 请求,内核空间是被动接收方,异步 io 是系统内核主动发起 io 请求用户空间是被动接收方.")]),t._v(" "),e("h2",{attrs:{id:"同步非阻塞"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同步非阻塞"}},[t._v("#")]),t._v(" 同步非阻塞")]),t._v(" "),e("p",[t._v("非阻塞 io,者用户空间不需要内核 io 操作完成可以立即返回用户空间执行用户操作,即处于非阻塞状态.内核会立即返回给用户一个状态值.阻塞是用户空间(调用线程)一直等待不能干别的事,非阻塞是用户空间拿到内核返回的状态值就返回给自己的调用线程,io 操作可以做就做,不可以就去做别的事.")]),t._v(" "),e("h2",{attrs:{id:"io多路复用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#io多路复用"}},[t._v("#")]),t._v(" io多路复用")]),t._v(" "),e("p",[t._v("异步阻塞 io, reactor 反应器设计模式")]),t._v(" "),e("h2",{attrs:{id:"异步-io"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步-io"}},[t._v("#")]),t._v(" 异步 io")]),t._v(" "),e("p",[t._v("用户空间与内核空间调用方式反过来用户空间线程是被动接受者,内核空间成了主动调用者.用户空间线程向内核空间注册各种 io 事件回调函数,由内核主动调用.")])])}),[],!1,null,null,null);a.default=r.exports}}]);