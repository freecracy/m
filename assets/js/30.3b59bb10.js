(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{445:function(a,t,s){a.exports=s.p+"assets/img/redis-zset-yanchiduilie.126774b7.png"},446:function(a,t,s){a.exports=s.p+"assets/img/rabbit-yanchiduilie.62a9abaa.png"},571:function(a,t,s){"use strict";s.r(t);var e=s(20),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"延时消息"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#延时消息"}},[a._v("#")]),a._v(" 延时消息")]),a._v(" "),e("h2",{attrs:{id:"redis过期回调"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis过期回调"}},[a._v("#")]),a._v(" Redis过期回调")]),a._v(" "),e("p",[a._v("开启监听 key 是否过期事件,一旦 key 过期就会触发一个 callback 事件")]),a._v(" "),e("div",{staticClass:"language-shell line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# redis.conf")]),a._v("\nnotify-keyspace-events Ex\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])]),e("h2",{attrs:{id:"cron-和-轮询数据库"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cron-和-轮询数据库"}},[a._v("#")]),a._v(" cron 和 轮询数据库")]),a._v(" "),e("h2",{attrs:{id:"zset"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#zset"}},[a._v("#")]),a._v(" Zset")]),a._v(" "),e("h3",{attrs:{id:"实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[a._v("#")]),a._v(" 实现")]),a._v(" "),e("p",[a._v("score 值表示元素过期时间,消费端轮询队列,将最小时间和当前时间比对小于当前时间表示已过期,移除 key")]),a._v(" "),e("ol",[e("li",[a._v("入队操作 : "),e("code",[a._v("zadd key timstamp task")]),a._v(",时间复杂度 O(logN)")]),a._v(" "),e("li",[a._v("起一个进程定时通过"),e("code",[a._v("zrangebyscore key -inf +inf limit 0 1 wichscores")]),a._v("获取 score 最小元素,时间复杂度 O(logN+M), N 元素个数,M 查询个数\n"),e("ul",[e("li",[a._v("查询出的分数小于等于当前时间戳,说明任务需要执行,则去异步执行该任务")]),a._v(" "),e("li",[a._v("查询出的分数大于当前时间戳,说明 zset 中的任务都没有到达执行时间,则休眠一定时间后继续执行")])])])]),a._v(" "),e("h3",{attrs:{id:"设计思路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计思路"}},[a._v("#")]),a._v(" 设计思路")]),a._v(" "),e("p",[e("img",{attrs:{src:s(445),alt:"redis-zset-yanchiduilie"}})]),a._v(" "),e("ol",[e("li",[a._v("将延迟任务通过 hash 算法路由至不同的 key\n"),e("ul",[e("li",[a._v("避免一个 key 存储了较多延时消息,入队,即查询变慢")]),a._v(" "),e("li",[a._v("系统横向扩展,数量激增时通过增加 key 数量扩展系统")])])]),a._v(" "),e("li",[a._v("每个 key 都对应建立一个处理进程,event 进程,通过 zragebyscore 轮询 key 查询是否有待处理的延迟消息")]),a._v(" "),e("li",[a._v("所有 event 进程只负责分发消息,具体业务逻辑通过一个额外消息队列异步处理\n"),e("ul",[e("li",[a._v("event 进程只负责分发消息,处理速度非常快,不会导致消息堆积")]),a._v(" "),e("li",[a._v("采用额外的消息队列后,消息处理可扩展性好,通过增加消费者数量可以扩展系统消息处理能力")])])]),a._v(" "),e("li",[a._v("event 进程通过 zk 选主但进程部署,避免 event 进程宕机后, key 中消息堆积.一旦 leader 主机宕机,会自动选择主 leader 来处理 key 中消息")])]),a._v(" "),e("h3",{attrs:{id:"优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[a._v("#")]),a._v(" 优点")]),a._v(" "),e("p",[a._v("直观快速落地、依赖 redis 自身持久化、使用 redis 集群来支持高并发和高可用.")]),a._v(" "),e("h3",{attrs:{id:"缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[a._v("#")]),a._v(" 缺点")]),a._v(" "),e("p",[a._v("有数据丢失的可能性")]),a._v(" "),e("h2",{attrs:{id:"rabbitmq"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#rabbitmq"}},[a._v("#")]),a._v(" RabbitMQ")]),a._v(" "),e("h3",{attrs:{id:"简介"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),e("p",[a._v("本身不支持延迟队列,但依靠死信队列和 TTL 可以实现延迟效果.")]),a._v(" "),e("h3",{attrs:{id:"死信队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#死信队列"}},[a._v("#")]),a._v(" 死信队列")]),a._v(" "),e("p",[a._v("当生产和消费消息时,以下情况会变成死信,消息一旦变成死信,便会被重新投递到死信交换机然后死信交换机根据绑定规则转发到对应的死信队列上,监听该队列就可以让消息被重新消费了 :")]),a._v(" "),e("ol",[e("li",[a._v("消息被拒绝,并且不再重新投递")]),a._v(" "),e("li",[a._v("消息超时未消费,即 TTL 过期了")]),a._v(" "),e("li",[a._v("消息队列达到最大长度")])]),a._v(" "),e("h3",{attrs:{id:"消息生成时间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#消息生成时间"}},[a._v("#")]),a._v(" 消息生成时间")]),a._v(" "),e("ol",[e("li",[a._v("直接在创建队列的时候设置整个队列的过期时间,所有进入队列的消息都被设置成统一的过期时间,一旦消息过期就会被丢弃,进入死信队列,在延迟队列的延时时间为固定值时比较合适")]),a._v(" "),e("li",[a._v("针对单条消息设置 TTL, 这种方式设置的 TTL,消息可能不会按时死亡,因为 Rabbit 会检查第一个消息是否过期,如 : 第一个设置 20s,第二个设置 10s,会等到第一个消息过期后,才会让第二个消息过期,可以通过安装插件解决")])]),a._v(" "),e("h3",{attrs:{id:"实现-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现-2"}},[a._v("#")]),a._v(" 实现")]),a._v(" "),e("p",[e("img",{attrs:{src:s(446),alt:"rabbit-yanchiduilie"}})]),a._v(" "),e("p",[a._v("将 TTL 设置为延时时间,投递到普通队列,不去消费,那么 TTL 时间后,消息会自动被投递到死信队列,使用消费者进程实时消费死信队列,就可以实现延迟队列效果")]),a._v(" "),e("h3",{attrs:{id:"优势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优势"}},[a._v("#")]),a._v(" 优势")]),a._v(" "),e("p",[a._v("可靠发送、可靠投递、死信队列来保证至少被消费一次及未被正确处理的消息不会被丢弃、集群解决单点问题")]),a._v(" "),e("h2",{attrs:{id:"时间轮"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#时间轮"}},[a._v("#")]),a._v(" 时间轮")]),a._v(" "),e("h3",{attrs:{id:"简介-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简介-2"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),e("p",[a._v("环形队列(数组) + 双向环形链表,链表中每一项代表一个需要执行的延迟任务,kafka 是基于时间轮实现的.")]),a._v(" "),e("h3",{attrs:{id:"添加延迟任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#添加延迟任务"}},[a._v("#")]),a._v(" 添加延迟任务")]),a._v(" "),e("p",[a._v("可以计算延迟任务在时间轮中的位置,将任务添加到双向环形链表到尾部.")]),a._v(" "),e("h3",{attrs:{id:"多层时间轮"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多层时间轮"}},[a._v("#")]),a._v(" 多层时间轮")]),a._v(" "),e("p",[a._v("第一层每格 N 秒,第二层每格 N * M 秒,第三轮 N * M * M 秒. M 是环形队列(数组)长度.")]),a._v(" "),e("h3",{attrs:{id:"delayqueue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#delayqueue"}},[a._v("#")]),a._v(" DelayQueue")]),a._v(" "),e("p",[a._v("kafka 使用 delayQueue 推送时间轮滚动,解决多数 bucket 为空导致时间轮滚动效率低下问题.")]),a._v(" "),e("h2",{attrs:{id:"存储"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#存储"}},[a._v("#")]),a._v(" 存储")]),a._v(" "),e("p",[a._v("key + list + 文件(到期时间远的存文件) + 内存 + 时分秒")]),a._v(" "),e("h2",{attrs:{id:"高可用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高可用"}},[a._v("#")]),a._v(" 高可用")]),a._v(" "),e("p",[a._v("redis 主从")])])}),[],!1,null,null,null);t.default=r.exports}}]);