(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{413:function(s,e,a){s.exports=a.p+"assets/img/clientcache-putong.12259be8.png"},414:function(s,e,a){s.exports=a.p+"assets/img/clientcache-guangbo.90da8860.png"},648:function(s,e,a){"use strict";a.r(e);var t=a(20),n=Object(t.a)({},(function(){var s=this,e=s.$createElement,t=s._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"客户端缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#客户端缓存"}},[s._v("#")]),s._v(" 客户端缓存")]),s._v(" "),t("h2",{attrs:{id:"订阅方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#订阅方式"}},[s._v("#")]),s._v(" 订阅方式")]),s._v(" "),t("ol",[t("li",[s._v("自动订阅 : 客户端开启后服务器会自动帮客户端订阅读取的所有 key")]),s._v(" "),t("li",[s._v("手动订阅 : 在需要缓存的读 key 之前打上一表特殊的标记,接下来这条指令读取的值会缓存在内存里")]),s._v(" "),t("li",[s._v("前缀指令订 : 客户端一次订阅以固定前缀开头的所有 key , 如果前缀对应的 key 非常多而且更新很频繁会给服务器带来广播风暴,影响服务器性能")])]),s._v(" "),t("h2",{attrs:{id:"实现方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现方式"}},[s._v("#")]),s._v(" 实现方式")]),s._v(" "),t("h2",{attrs:{id:"发布订阅的两种实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#发布订阅的两种实现"}},[s._v("#")]),s._v(" 发布订阅的两种实现")]),s._v(" "),t("ol",[t("li",[s._v("自定义 channel 当运行缓存变化时,修改方需要执行 publish 指令,消费方订阅这个 channel,收到消息时刷新本地缓存每个业务点需要对立不一样的 channel ,增加 channel 维护")]),s._v(" "),t("li",[s._v("使用 key 通知事件的内置 channel,某个 key 被删除会想 del channel 发送 del 事件,,某个 key 过期会想 expire channel 发送 expire 事件,当某个 key 被 set 时,会想 set channel 发送一个 set 事件,会导致客户端需要监听许多内置 channel 才知道内存缓存关联的哪个 key 发生了变化,如果开启 keyspace notification event 事件发生太频繁会影响服务器性能,还会有惊群问题,不想关心的事件也会收到通知,因为这里的内置 channel 是所有 key 共享的,任意 key 发生变化 channel 的消费者都能收到事件通知")])]),s._v(" "),t("h2",{attrs:{id:"访问延迟"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#访问延迟"}},[s._v("#")]),s._v(" 访问延迟")]),s._v(" "),t("ol",[t("li",[t("p",[s._v("慢日志复杂度高的命令 : 通常 sort、sunion、zunionstore,等复杂命令,请求量不大但 cpu 使用率偏高,通常由复杂度高的命令导致")]),s._v(" "),t("p",[s._v("解决方法 : 不使用复杂度高的命令,一次不要获取太多数据,每次尽量操作少量数据")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("config "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" slowlog-slower-than "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("5000")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 命令执行超过 5 毫秒记录慢日志")]),s._v("\nconfig "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" slowlog-max-len "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("1000")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 保留最近 1000 条慢日志")]),s._v("\nshow get "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 查询最近 5 条慢日志")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br")])])]),s._v(" "),t("li",[t("p",[s._v("慢日志大 key : 慢日志中如果出现 set、delete 等命可能除了复杂度高的命令还有大 key 操作.大 key 写入和删除都会分配和释放内存.4.0 版本后删除可异步释放内存")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("redis-cli -h "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("host")]),s._v(" -p port --bitkeys -i "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0.01")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 扫描是否存在大 key, -i 控制扫描频率,内部执行 scan 遍历所有 key")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])])]),s._v(" "),t("li",[t("p",[s._v("集中过期 : 过期删除不会出现在慢日志中,")]),s._v(" "),t("p",[s._v("解决方法 : 搜索 expireat 和 pexpireat,后增加随机时间")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("info\nexpired_key "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 目前为止,累计删除的过期 key 数量需要监控,突增时需要报警")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])])]),s._v(" "),t("li",[t("p",[s._v("内存达到上限 : 写入新数据时在执行内存淘汰策略")])]),s._v(" "),t("li",[t("p",[s._v("fork 耗时")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("info\nlastest_fork_usec "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 最后一次 fork 耗时")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br")])])]),s._v(" "),t("li",[t("p",[s._v("绑定 cpu : 绑定后 fork 的子进程也会消耗 cpu 资源")])]),s._v(" "),t("li",[t("p",[s._v("开启 aof : aof 刷盘策略不合理")])]),s._v(" "),t("li",[t("p",[s._v("使用 swap : 需要对内存和 swap 使用监控,内存不足和使用到 swap 即时报警")])]),s._v(" "),t("li",[t("p",[s._v("监控网卡带宽不要影响 redis")])])]),s._v(" "),t("h2",{attrs:{id:"三种模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三种模式"}},[s._v("#")]),s._v(" 三种模式")]),s._v(" "),t("h3",{attrs:{id:"普通模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#普通模式"}},[s._v("#")]),s._v(" 普通模式")]),s._v(" "),t("p",[s._v("当 tracking 开启时,redis 会记住每个客户端请求的 key,当 key 值发生变化会发送失效信息给客户端.")]),s._v(" "),t("ul",[t("li",[s._v("sever 将 client 访问的 key 及 客户端 id 存储在全局唯一 trackingtable 表中,当表满了,移除最老记录,同时触发记录过期通知 client")]),s._v(" "),t("li",[s._v("当连接断开,清除 client id 对应的记录")]),s._v(" "),t("li",[s._v("tracking table 不记录哪个 database 任何一个 db 修改都会通知客户端,服务端对于记录的 key 只会报告一次,所以收到后要继续 trace")])]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("client tracking ON"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v("OFF\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[t("img",{attrs:{src:a(413),alt:"客户端缓存:普通模式"}})]),s._v(" "),t("h4",{attrs:{id:"基数树"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基数树"}},[s._v("#")]),s._v(" 基数树")]),s._v(" "),t("p",[s._v("针对稀疏的长整型数据查找的多叉搜索树,用来存储键的指针和客户端 id 映射关系.")]),s._v(" "),t("h3",{attrs:{id:"广播模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#广播模式"}},[s._v("#")]),s._v(" 广播模式")]),s._v(" "),t("p",[s._v("服务端不会记录客户端访问了哪些键,所以不消耗内存,服务端会给所有客户端广播,在实际应用中我们让客户端注册跟踪指定前缀的 key.使用基数树存储前缀字符串指针和需要通知的 key 和客户端 id 映射关系.")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[s._v("client trancking on bcast prefix xxx\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br")])]),t("p",[t("img",{attrs:{src:a(414),alt:"客户端缓存:广播模式"}})]),s._v(" "),t("h3",{attrs:{id:"转发模式-重定向模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#转发模式-重定向模式"}},[s._v("#")]),s._v(" 转发模式(重定向模式)")]),s._v(" "),t("p",[s._v("普通模式、广播模式需要客户端使用 resp3 协议, resp2 无法直接 push 消息,所以需要一个支持 resp3 的客户端告诉 server 将失效消息 pus/sub 通知 resp2 客户端.")]),s._v(" "),t("p",[s._v("需要执行 subscribe 订阅用于发送失效消息的频道 "),t("code",[s._v("_redis_:invalidata")]),s._v(",再使用另外一个客户端执行"),t("code",[s._v("client trace")]),s._v("设置服务端将失效消息转发给 resp 2 客户端.")]),s._v(" "),t("div",{staticClass:"language-shell line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-shell"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# resp2 客户端")]),s._v("\nsubscribe _redis_:invalidate\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# resp3 客户端")]),s._v("\nclient tracking on bcast redirect "),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("606")]),s._v("\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br")])])])}),[],!1,null,null,null);e.default=n.exports}}]);