(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{585:function(t,v,_){"use strict";_.r(v);var a=_(20),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"垃圾回收"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[t._v("#")]),t._v(" 垃圾回收")]),t._v(" "),_("h3",{attrs:{id:"stop-the-world"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#stop-the-world"}},[t._v("#")]),t._v(" stop the world")]),t._v(" "),_("ol",[_("li",[t._v("第一阶段预先占有所有运行的 groutine,一旦被占有 groutine 将保存在一个安全的状态上(等待 goroutine 主动停止).")]),t._v(" "),_("li",[t._v("然后调度器将所有 M 从 P 上分离,放入 idle M 队列,将 groutine 放入 global 队列")]),t._v(" "),_("li",[t._v("停止就绪后唯一一个活跃 gc groutine 将在 gc 结束后,start the world")])]),t._v(" "),_("blockquote",[_("p",[t._v("M 线程")]),t._v(" "),_("p",[t._v("P 资源,线程运行的上下文.")])]),t._v(" "),_("p",[t._v("The system call here is exiting while the world is stopped. However, since there is no available P — they are all marked as stopped")]),t._v(" "),_("ol",[_("li",[t._v("引用计数:不会造成 stw,有循环引用问题")]),t._v(" "),_("li",[t._v("标记-清除:初始时为白色,标记时用黑色,清扫所有白色对象")]),t._v(" "),_("li",[t._v("新生代、老生代:相对于标记清除扫描空间更小,新生代长时间未清除的对象移动到老生代.")])]),t._v(" "),_("h3",{attrs:{id:"三色标记法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三色标记法"}},[t._v("#")]),t._v(" 三色标记法")]),t._v(" "),_("ol",[_("li",[t._v("所有对象(根对象 : 栈上的变量和堆上的全局变量)最初都为白色")]),t._v(" "),_("li",[t._v("将所有可达对象(全局对象、栈对象)标记为灰色")]),t._v(" "),_("li",[t._v("任意取一灰色对象,将它引用的所有白色对象标记为灰色,然后将自身标记为黑色")]),t._v(" "),_("li",[t._v("重复上一步到找不到灰色对象")]),t._v(" "),_("li",[t._v("剩下对象非黑即白")]),t._v(" "),_("li",[t._v("所有黑色都是可达的,白色是不可达,回收白色对象")])]),t._v(" "),_("p",[t._v("白色对象是不可达对象,灰色对象本身被引用但子节点没处理完,黑色表示本身被引用和已处理对象中的子引用.标记完成后不存在灰色对象,黑色为活跃对象,标记为白色的将被回收,")]),t._v(" "),_("p",[t._v("黑色对象不可引用白色对象.因为黑色引用的白色对象永远不会被扫描.该约束由写屏障实现.")]),t._v(" "),_("h3",{attrs:{id:"指针"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#指针"}},[t._v("#")]),t._v(" 指针")]),t._v(" "),_("p",[t._v("go 语言中的指针是有类型的,指针类型不能相互转换.unsafe.pointer 不受类型约束.")]),t._v(" "),_("ol",[_("li",[t._v("go 中任何类型的指针都可以转化为 unsafe.pointer 类型")]),t._v(" "),_("li",[t._v("unsafe.pointer 类型可以转换为 go 语言常规的任何类型的指针")]),t._v(" "),_("li",[t._v("uintptr 类型可以转换为 unsafe.pointer")]),t._v(" "),_("li",[t._v("unsafe.pointer 可以转换为 uintptr 类型")])]),t._v(" "),_("p",[t._v("unsafe.pointer 多用于 go 多编译时期,由于可以绕过类型系统直接访问内存,所以效率比较高,但因为不安全所以不建议使用.")]),t._v(" "),_("h2",{attrs:{id:"stw"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#stw"}},[t._v("#")]),t._v(" STW")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("行为")]),t._v(" "),_("th",[t._v("STW")]),t._v(" "),_("th",[t._v("说明")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("标记开始")]),t._v(" "),_("td",[t._v("会")]),t._v(" "),_("td",[t._v("开启写屏障和辅助 GC")])]),t._v(" "),_("tr",[_("td",[t._v("并发标记")]),t._v(" "),_("td",[t._v("不会")]),t._v(" "),_("td")]),t._v(" "),_("tr",[_("td",[t._v("标记结束")]),t._v(" "),_("td",[t._v("会")]),t._v(" "),_("td",[t._v("禁用写屏障和辅助 GC")])])])]),t._v(" "),_("h2",{attrs:{id:"gogc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#gogc"}},[t._v("#")]),t._v(" GOGC")]),t._v(" "),_("p",[t._v("当前新分配到数值与上次收集后剩余实际数值的比例.")]),t._v(" "),_("p",[t._v("标记阶段遍历堆上所有引用对象并将他们标记为任在使用此阶段后所有未标记的内容将视为垃圾在清除阶段清除并重新分配.")]),t._v(" "),_("p",[t._v("清除非常快, GC 主要耗时是标记.与活动内存量成正比,跟堆大小没他大关系.在堆上多余的垃圾不会增加标记时间.")]),t._v(" "),_("p",[t._v("默认堆大小加倍时触发 GC,在当前标记终止阶段设置下一个堆触发大小,当标记所有活动内存之后总堆大小是当前活动内存 2 倍时, 2x 来自变量 GOGC.")]),t._v(" "),_("ol",[_("li",[t._v("程序创建的对象都是白色")]),t._v(" "),_("li",[t._v("扫描所有可达对象标记为灰色")]),t._v(" "),_("li",[t._v("从灰色对象找到其引用对象标记为灰色,把灰色对象本身标记为黑色")]),t._v(" "),_("li",[t._v("监视对象中内存修改,知道灰色标记的对象不存在")]),t._v(" "),_("li",[t._v("gc 回收白色对象")]),t._v(" "),_("li",[t._v("将所有黑色对象标记为白色")])]),t._v(" "),_("p",[t._v("只要不触及黑色对象只清除白色对象,不会影响程序逻辑.清除操作和用户逻辑可以并发.标记操作和用户逻辑也可以并发.")]),t._v(" "),_("p",[t._v("写屏障(标记阶段) : 该屏障之前的写操作和之后的写操作被系统,gc 过程中监视对象对内存的修改,重新标记,新生成的对象一律标记为灰色.一个黑色对象引用了曾经标记的白色对象写屏障触发,向 gc 发送信号,gc 重新扫描对象并标记为灰色.所以无论创建对象还是对象应用改变都会标记为灰色.")]),t._v(" "),_("p",[t._v("sync 包中的 pool 在 gc 运行时不会被清除")]),t._v(" "),_("h2",{attrs:{id:"不被-gc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不被-gc"}},[t._v("#")]),t._v(" 不被 GC")]),t._v(" "),_("div",{staticClass:"language-go line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-go"}},[_("code",[t._v("runtime"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),_("span",{pre:!0,attrs:{class:"token function"}},[t._v("KeepAlive")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])]),t._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[t._v("1")]),_("br")])]),_("p",[t._v("找出所有的全局变量和当前函数栈里的变量标记为可达,从已经标记的数据开始,标记他们的可访问变量.混合写屏障将垃圾收集时间缩短到 0.5ms 以内.")]),t._v(" "),_("h2",{attrs:{id:"混合写屏障"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#混合写屏障"}},[t._v("#")]),t._v(" 混合写屏障")]),t._v(" "),_("p",[t._v("插入写屏障和删除写屏障构成混合写屏障,将覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记为灰色,标记阶段完成时暂停程序,将所有栈对象标记成灰色并重新扫描,为了移除之前栈的重新扫描,后续版本在标记阶段还需要将创建的所有对象都标记成黑色,放置新分配的栈内存和堆内存被错误回收,因为栈内在标记阶段最终都会变为黑色,所以不需要重新扫描栈空间,放置写屏障标记成的灰色对象下次 gc 时回收.")]),t._v(" "),_("h2",{attrs:{id:"三色不变性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三色不变性"}},[t._v("#")]),t._v(" 三色不变性")]),t._v(" "),_("ul",[_("li",[t._v("强三色不变性 : 黑色对象不会指向白色对象,只会指向灰色对象或者黑色对象")]),t._v(" "),_("li",[t._v("弱三色不变性 : 黑色对象执行的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径")])]),t._v(" "),_("h2",{attrs:{id:"完整-gc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#完整-gc"}},[t._v("#")]),t._v(" 完整 GC")]),t._v(" "),_("h3",{attrs:{id:"标记准备阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#标记准备阶段"}},[t._v("#")]),t._v(" 标记准备阶段")]),t._v(" "),_("p",[t._v("暂停程序 : 所有处理器在这时会进入安全点")]),t._v(" "),_("h3",{attrs:{id:"标记阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#标记阶段"}},[t._v("#")]),t._v(" 标记阶段")]),t._v(" "),_("ol",[_("li",[t._v("将状态切换至 _GCmark、开启写屏障、用户程序协助并将对象入队")]),t._v(" "),_("li",[t._v("恢复执行程序,标记 goroutine 和 普通 goroutine 开始并发标记内存中的对象,写屏障会将被覆盖的指针和新指针标记成灰色,而所有新创建对象都会直接标记为黑色")]),t._v(" "),_("li",[t._v("开始扫描根对象,包括所有 goroutine 的栈、全局对象、以及不在堆中的运行时数据结构,扫描 goroutine 期间会暂停当前处理器")]),t._v(" "),_("li",[t._v("依次处理灰色对象标记成黑色并将他们指向的对象标记成灰色")]),t._v(" "),_("li",[t._v("分布式终止算法检查剩余工作")])]),t._v(" "),_("p",[t._v("标记开始时收集器会抢占 25% cpu,剩下 75% 给用户程序,一旦收集器认为处理不过来了,就会改变该配比,收集器会抢占,这部分被抢占的 goroutine 叫做 mark assist.一旦某次 gc 中用到了 mark assist 下次 gc 就会提前开始,尽量减少 mark assist 的使用.")]),t._v(" "),_("h3",{attrs:{id:"标记终止阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#标记终止阶段"}},[t._v("#")]),t._v(" 标记终止阶段")]),t._v(" "),_("p",[t._v("暂停程序,将状态切换至 _GCmarkermination 并关闭辅助标记的用户程序,清理处理器上的线程缓存")]),t._v(" "),_("h3",{attrs:{id:"清理阶段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#清理阶段"}},[t._v("#")]),t._v(" 清理阶段")]),t._v(" "),_("ol",[_("li",[t._v("将状态切换至 _GCoff 开始清理,初始化清理状态,并关闭写屏障")]),t._v(" "),_("li",[t._v("恢复用户程序,所有新创建对象会被标记为白色")]),t._v(" "),_("li",[t._v("后台并发清理所有内存单元,当 goroutine 申请新的内存单元时就会触发清理")])]),t._v(" "),_("p",[t._v("清理过程是并发进行的,清扫的开销会增加到分配堆内存的过程.不会与垃圾回收的延迟相关联")]),t._v(" "),_("h3",{attrs:{id:"小结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[t._v("#")]),t._v(" 小结")]),t._v(" "),_("p",[t._v("标记准备和标记结束阶段需要 STW,标记阶段会减少程序性能,清理阶段不会对程序由影响.GC 并发是指 GC 和应用程序 goroutine 同时执行.")]),t._v(" "),_("h2",{attrs:{id:"指针对象"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#指针对象"}},[t._v("#")]),t._v(" 指针对象")]),t._v(" "),_("p",[t._v("所有显示 *T 以及内部包含 pointer 的对象都是指针类型,如 slice.")]),t._v(" "),_("p",[t._v("map 如果 key/value 值类型大小超过 128 字节就会退化成指针.")])])}),[],!1,null,null,null);v.default=s.exports}}]);