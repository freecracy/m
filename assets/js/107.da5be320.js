(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{639:function(a,e,r){"use strict";r.r(e);var t=r(20),v=Object(t.a)({},(function(){var a=this,e=a.$createElement,r=a._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"etcd"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#etcd"}},[a._v("#")]),a._v(" etcd")]),a._v(" "),r("h2",{attrs:{id:"概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),r("p",[a._v("一个集群三个节点,一个 leader 和两个 follower.每个节点通过 raft 算法同步数据,并通过 boltdb 存储数据.一个节点挂掉后另外的节点会自动选举一个 leader. 客户端可以连接任何一个节点完成请求.")]),a._v(" "),r("ol",[r("li",[a._v("网络层 : raft 层,通过网络同步数据")]),a._v(" "),r("li",[a._v("存储层 : treeindex 存储层和 boltdb 持久化存储 key/value 层.")])]),a._v(" "),r("h2",{attrs:{id:"内存分配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存分配"}},[a._v("#")]),a._v(" 内存分配")]),a._v(" "),r("p",[a._v("内部默认为 4kb 的页面来存储数据,当用户想要删除数据的时候,并不会把这个存储空间立即还给操作系统,内部先留下来,维护一个页面池子,这个页面池子叫做 freelist.当新数据需要一个连续页面为 n 的配置时,旧算法会从头扫描,返回可用页面起始地址.新算法将连续页面大小作为 hashmap 的 key value 是起始 ID 的配置集合,当需要新页面存储时 O(1) 的时间复杂度来查询 hashmap 值,快速找到起始 ID.释放页面时通过向前向后合并形成一个大的连续页面.")]),a._v(" "),r("h2",{attrs:{id:"zookeeper"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper"}},[a._v("#")]),a._v(" zookeeper")]),a._v(" "),r("p",[a._v("只有 leader 可以写入(其它节点收到写入请求会将请求转发给 leader 节点),follower 和 observer 只负责读,但是 follower 也会参与节点选举和过半写成功,observer 只单纯提供读.客户端和服务端使用 tcp 长连接保持通信.会有心跳检测机制,也可以接受服务器的 watch 通知机制(用户可以在指定节点注册watcher,事件触发时客户端就会收到服务端的通知).")]),a._v(" "),r("h3",{attrs:{id:"使用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[a._v("#")]),a._v(" 使用场景")]),a._v(" "),r("ol",[r("li",[a._v("命名服务 : 服务发现,可以生成全局唯一的节点 ID")]),a._v(" "),r("li",[a._v("分布式协调 : 利用 watcher 监听机制一个节点发生变化,另外系统可以得到通知")]),a._v(" "),r("li",[a._v("集群管理")]),a._v(" "),r("li",[a._v("分布式锁")]),a._v(" "),r("li",[a._v("master 选举 : zookeeper 节点的全局唯一性")])]),a._v(" "),r("h3",{attrs:{id:"watcher"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#watcher"}},[a._v("#")]),a._v(" watcher")]),a._v(" "),r("h4",{attrs:{id:"特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),r("ol",[r("li",[a._v("一次性 : 一旦 watcher 触发后,会从存储中移除")]),a._v(" "),r("li",[a._v("客户端串行 :")]),a._v(" "),r("li",[a._v("轻量 : 通知单位是 watcherEvent 只包含通知状态、事件类型和节点路径,不包含具体的事件内容,需客户端主动重新获取数据.")])]),a._v(" "),r("h4",{attrs:{id:"流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#流程"}},[a._v("#")]),a._v(" 流程")]),a._v(" "),r("ol",[r("li",[a._v("客户端向服务端注册 watcher 监听")]),a._v(" "),r("li",[a._v("保存 watcher 对象到客户端本地的 watcherManager 中")]),a._v(" "),r("li",[a._v("服务端 watcher 事件触发后,客户端收到服务端通知,从 WatcherManager 中取出对应的 watcher 对象执行回调逻辑")])]),a._v(" "),r("h3",{attrs:{id:"数据一致性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据一致性"}},[a._v("#")]),a._v(" 数据一致性")]),a._v(" "),r("p",[a._v("通过 zab 原子广播协议实现最终一致性,类似 2PC 两阶段提交过程.")]),a._v(" "),r("h4",{attrs:{id:"流程-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#流程-2"}},[a._v("#")]),a._v(" 流程")]),a._v(" "),r("ol",[r("li",[a._v("leader 收到请求后将转换为一个提议,并分配全局唯一递增事务 ID zxid,然后把提议放入一个 FIFO 队列,按照 FIFO 策略分发给所有 follower")]),a._v(" "),r("li",[a._v("follower 收到提以后,以事务日志形式写入到本地磁盘,写入成功后返回 ack 给 leader")]),a._v(" "),r("li",[a._v("leader 收到超过半数 follower 的 ack 后即可认为数据写入成功,就会发送 commit 命令给 follower 告诉他们可以提交提议了.")])]),a._v(" "),r("h4",{attrs:{id:"崩溃恢复和消息广播"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#崩溃恢复和消息广播"}},[a._v("#")]),a._v(" 崩溃恢复和消息广播")]),a._v(" "),r("p",[a._v("整个集群在异常下会进入崩溃恢复状态,会选举产生 leader 节点,当集群半数节点都和 leader 状态同步后,zab 会退出恢复模式,然后进入消息广播模式.")]),a._v(" "),r("h3",{attrs:{id:"leader-选举"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#leader-选举"}},[a._v("#")]),a._v(" leader 选举")]),a._v(" "),r("p",[a._v("主要包含事务 zxid 和 myid, 节点主要 leading、following、looking 3种状态.")]),a._v(" "),r("h4",{attrs:{id:"服务启动时选举"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务启动时选举"}},[a._v("#")]),a._v(" 服务启动时选举")]),a._v(" "),r("ol",[r("li",[a._v("每个节点会对自己进行投票,然后把投票信息广播给集群中其它节点")]),a._v(" "),r("li",[a._v("节点收到其它节点投票信息和自己的投票信息,zxid 较大优先,如果 zxid 相同则选择 myid 大者,此时大家都是 looking 状态")]),a._v(" "),r("li",[a._v("投票完成后,统计投票信息,如果集群中半数机器都选择了某个节点为 leader,选举结束")]),a._v(" "),r("li",[a._v("更新各个节点状态 leader 改为 leading 状态,follower 改为 following 状态")])]),a._v(" "),r("h4",{attrs:{id:"服务运行期间的选举"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务运行期间的选举"}},[a._v("#")]),a._v(" 服务运行期间的选举")]),a._v(" "),r("ol",[r("li",[a._v("leader 宕机,非 observer 节点会把自己的状态修改为 looking 状态,重新进入选举流程")]),a._v(" "),r("li",[a._v("生成投票信息(myid、zxid),第一轮投票都会把票投给自己,然后把投票信息广播出去")]),a._v(" "),r("li",[a._v("和启动时相同,优先 zxid 然后 myid,最后统计投票信息,修改节点状态,选举结束")])]),a._v(" "),r("h4",{attrs:{id:"选举后数据同步"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#选举后数据同步"}},[a._v("#")]),a._v(" 选举后数据同步")]),a._v(" "),r("p",[a._v("选举结束后 follower 和 observer 统称为 learner 会向 leader 注册,然后开始数据同步")])])}),[],!1,null,null,null);e.default=v.exports}}]);