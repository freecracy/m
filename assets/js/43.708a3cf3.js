(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{474:function(t,a,s){t.exports=s.p+"assets/img/jinchengtongxin.791fdb52.png"},537:function(t,a,s){"use strict";s.r(a);var v=s(20),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"操作系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#操作系统"}},[t._v("#")]),t._v(" 操作系统")]),t._v(" "),v("h2",{attrs:{id:"内存管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[t._v("#")]),t._v(" 内存管理")]),t._v(" "),v("p",[t._v("cpu 组件 MMU (内存管理单元)(页表、快表 TLB)将虚拟地址转换成物理地址供进程使用.")]),t._v(" "),v("h3",{attrs:{id:"内存分段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存分段"}},[t._v("#")]),t._v(" 内存分段")]),t._v(" "),v("p",[t._v("分为代码段、数据段(初始化的数据、未初始化的数据)、文件映射区、堆、栈四部分,虚拟地址通过段表与物理地址映射,分段机制把虚拟内存地址分为 4 段,每个段在段表都有一项,在这找到段的基地址,再加上偏移量找到物理内存地址.段表存储在进程表中.")]),t._v(" "),v("blockquote",[v("p",[t._v("分段会有内存碎片和内存交换效率低等问题")])]),t._v(" "),v("p",[t._v("外部内存碎片 : 生产了多个不连续的物理内存,导致新的程序无法加载,内存交换,重新载入程序,使之连续也就是 swap 分区")]),t._v(" "),v("p",[t._v("内部内存碎片 : 程序所有内存都被装载到物理内存,但这个程序部分内存并不连续")]),t._v(" "),v("h3",{attrs:{id:"内存分页"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存分页"}},[t._v("#")]),t._v(" 内存分页")]),t._v(" "),v("p",[t._v("每一个页的大小是 4kb,虚拟地址与物理地址通过页表来映射,页表会载入 MMU 当进程访问虚拟地址在页表中查不到时系统会产生缺页中断.页的 swap 要比段效率高.页号加偏移量就是物理地址. linux 使用分页管理,把每个段基地址设为 0,程序地址空间是线性地址空间,段只用于访问控制和内存保护.")]),t._v(" "),v("p",[t._v("内存惰性分配 : 对于一个运行中的进程,不是所有虚拟内存在物理内存中都有对应的页,程序运行时才去内存中寻找虚拟地址的对应页帧,找不到时才分配.")]),t._v(" "),v("h4",{attrs:{id:"多级页表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多级页表"}},[t._v("#")]),t._v(" 多级页表")]),t._v(" "),v("p",[t._v("MMU 管理单页表会占用很大空间.")]),t._v(" "),v("h3",{attrs:{id:"段页式内存管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#段页式内存管理"}},[t._v("#")]),t._v(" 段页式内存管理")]),t._v(" "),v("p",[t._v("地址由段号、段内页号、页内偏移")]),t._v(" "),v("ol",[v("li",[t._v("第一次访问段表,得到页表起始地址")]),t._v(" "),v("li",[t._v("第二次访问页表,得到物理页号")]),t._v(" "),v("li",[t._v("第三次将物理页号与页内位移组合得到物理地址")])]),t._v(" "),v("p",[t._v("TLB : 页缓存,负责缓存最近常被访问的页表项提高页的转换速度")]),t._v(" "),v("p",[t._v("缺页异常 : cpu 在 TLB 和 页表中都没有找到对应物理页的页帧或者权限.用户进程就会出现缺页中断,进程会从用户态切换到内核态将缺页中断交给内核处理")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("原因")]),t._v(" "),v("th",[t._v("简述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("访问越界")]),t._v(" "),v("td",[t._v("core dump 的来源,空指针引用或权限问题")])]),t._v(" "),v("tr",[v("td",[t._v("新申请内存")]),t._v(" "),v("td",[t._v("内存时延时分配的,当使用 malloc 申请时并不分配内存,当使用时发现没有才会启用申请")])]),t._v(" "),v("tr",[v("td",[t._v("访问数据被 swap 出")]),t._v(" "),v("td",[t._v("物理内存有限,内存页置换会被长时间未使用的物理内存页帧方到 swap 分区")])])])]),t._v(" "),v("h2",{attrs:{id:"dma"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#dma"}},[t._v("#")]),t._v(" DMA")]),t._v(" "),v("p",[t._v("主板上的一块独立芯片,直接存储器访问,无需 cpu 参与,让外设和系统内存之间双向数据传输的硬件机制,使 cpu 从 io 中摆脱出来,提高系统吞吐率.")]),t._v(" "),v("h2",{attrs:{id:"常用系统调用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常用系统调用"}},[t._v("#")]),t._v(" 常用系统调用")]),t._v(" "),v("p",[t._v("页缓存 : 写入磁盘时其实是写入页缓存中使得对磁盘的写入变成对内存的写入,写入的页就变成脏页,操作系统会在合适的时候将脏页写入磁盘.脏页可以通过 fsync 强制刷盘,刷盘开销大因此一般使用多副本来保证可靠,而不是同步刷盘.")]),t._v(" "),v("p",[t._v("缺页中断 : 在读取数据时如果页缓存命中则直接返回,如果缓存 miss 会产生却页中断从磁盘加载数据到页缓存中,然后返回数据.")]),t._v(" "),v("p",[t._v("预读 : 在读取数据时会根据局部性原理将相邻磁盘块读入缓存中.")]),t._v(" "),v("h2",{attrs:{id:"elementary-os"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#elementary-os"}},[t._v("#")]),t._v(" elementary os")]),t._v(" "),v("h2",{attrs:{id:"系统调用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#系统调用"}},[t._v("#")]),t._v(" 系统调用")]),t._v(" "),v("p",[t._v("调用操作系统的 read 是把数据从内核缓存区复制到进程缓存区,而 write 系统调用是把数据从进程缓存区复制到内核缓存区.进程的 io 操作不是物理设备级别的读写,而是缓存的复制,底层数据读写交换是操作系统内核来完成的.操作系统会对内核缓存区进行监控,等待缓存区达到一定数量再进行 io 设备的中断处理(外部设备的直接读写涉及操作系统的中断,发生中断需要保存之前的进行数和状态信息结束中断后要恢复之前的进程数据和状态等信息).集中执行物理设备的实际 io 操作.至于什么时候读中断、写中断由操作系统内核来决定.")]),t._v(" "),v("h2",{attrs:{id:"磁盘优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#磁盘优化"}},[t._v("#")]),t._v(" 磁盘优化")]),t._v(" "),v("h3",{attrs:{id:"零拷贝"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#零拷贝"}},[t._v("#")]),t._v(" 零拷贝")]),t._v(" "),v("h3",{attrs:{id:"直接-io"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#直接-io"}},[t._v("#")]),t._v(" 直接 IO")]),t._v(" "),v("h3",{attrs:{id:"异步-io"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#异步-io"}},[t._v("#")]),t._v(" 异步 IO")]),t._v(" "),v("h3",{attrs:{id:"内存缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存缓存"}},[t._v("#")]),t._v(" 内存缓存")]),t._v(" "),v("h2",{attrs:{id:"寄存器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#寄存器"}},[t._v("#")]),t._v(" 寄存器")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("寄存器")]),t._v(" "),v("th",[t._v("作用")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("通用寄存器")]),t._v(" "),v("td",[t._v("用来存放需要进行运算的数据")])]),t._v(" "),v("tr",[v("td",[t._v("程序计数器")]),t._v(" "),v("td",[t._v("存储 cpu 要执行的下一条指令所在的内存地址")])]),t._v(" "),v("tr",[v("td",[t._v("指令寄存器")]),t._v(" "),v("td",[t._v("存放程序计数器指向的指令,即指令本身,指令执行完成前存储在这里")])])])]),t._v(" "),v("h2",{attrs:{id:"总线"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总线"}},[t._v("#")]),t._v(" 总线")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("总线")]),t._v(" "),v("th",[t._v("作用")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("地址总线")]),t._v(" "),v("td",[t._v("指定 cpu 将要操作的内存地址")])]),t._v(" "),v("tr",[v("td",[t._v("数据总线")]),t._v(" "),v("td",[t._v("读写内存数据")])]),t._v(" "),v("tr",[v("td",[t._v("控制总线")]),t._v(" "),v("td",[t._v("发送和接收信号(中断、设备复位等), cpu 收到信号后响应")])])])]),t._v(" "),v("p",[t._v("读取数据 :")]),t._v(" "),v("ol",[v("li",[t._v("通过地址总线指定内存地址")]),t._v(" "),v("li",[t._v("通过数据总线传输数据")])]),t._v(" "),v("h2",{attrs:{id:"_32-位和-64-位"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_32-位和-64-位"}},[t._v("#")]),t._v(" 32 位和 64 位")]),t._v(" "),v("ol",[v("li",[t._v("32 位每次做多操作 32 位,如果计算超过 32 位需要多次计算,如果计算数字不超过 32 位,32 位和 64 位区别不大.超过 32 位计算,64 位才占有时")]),t._v(" "),v("li",[t._v("cpu 位宽为 32,最大能操作"),v("code",[t._v("2^32=4G")]),t._v("内存,即使 8G 内存也用不到, 64 位寻址范围较大")])]),t._v(" "),v("h2",{attrs:{id:"cpu-执行过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cpu-执行过程"}},[t._v("#")]),t._v(" cpu 执行过程")]),t._v(" "),v("ol",[v("li",[t._v("读取程序计数器的值,这个值是指令的内存地址,然后 cpu 的控制单元操作地址总线需要访问的内存地址,通知内存设备准备数据,数据准备好后通过数据总线将数指令数据传给 cpu,cpu 收到内存传来的数据将指令存入指令寄存器")]),t._v(" "),v("li",[t._v("cpu 分析执行寄存器中的指令,确定指令类型和参数,如果计算类指令把指令交给逻辑运算单元,如果存储类型指令,则交控制单元执行")]),t._v(" "),v("li",[t._v("cpu 执行完指令后程序计数器值自增,表示指向下一条指令,这个自增的大小由 cpu 位宽决定, 32 位 cpu 指令是 4 个字节,需要 4 个内存地址存放,因此程序计数器的值会自增 4")])]),t._v(" "),v("h2",{attrs:{id:"cpu-缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cpu-缓存"}},[t._v("#")]),t._v(" cpu 缓存")]),t._v(" "),v("div",{staticClass:"language-shell line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-shell"}},[v("code",[v("span",{pre:!0,attrs:{class:"token function"}},[t._v("cat")]),t._v(" /sys/devices/system/cpu/cpu0/cache/index0/size "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 查看 L1 cache 数据缓存大小")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("cat")]),t._v(" /sys/devices/system/cpu/cpu0/cache/index1/size "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 查看 L1 cache 指令缓存大小")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("cat")]),t._v(" /sys/devices/system/cpu/cpu0/cache/index2/size "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 查看 L2 cache 缓存大小")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("cat")]),t._v(" /sys/devices/system/cpu/cpu0/cache/index3/size "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 查看 L3 cache 缓存大小")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("cat")]),t._v(" /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# cache line 大小,缓存块大小,cache 一次载入数据大小")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br")])]),v("p",[t._v("L1 cache 通常分为数据缓存和指令缓存,数据和指令在 L1 是分开存储的,大小通常一样. L1 和 L2 都是每个 cpu 独有的,而 L3 是多个 cpu 共享的.所以一般 L3 要比 L1 和 L2 大很多.")]),t._v(" "),v("h2",{attrs:{id:"进程间通信"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程间通信"}},[t._v("#")]),t._v(" 进程间通信")]),t._v(" "),v("p",[t._v("每个进程的用户地址空间都是独立的,不能互相访问,内核空间是所有进程共享的,所以进程间通信必须通过内核.")]),t._v(" "),v("p",[v("img",{attrs:{src:s(474),alt:"进程通信"}})]),t._v(" "),v("h3",{attrs:{id:"信号"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#信号"}},[t._v("#")]),t._v(" 信号")]),t._v(" "),v("p",[t._v("一种软中断机制,只能做通知使用不能传输数据.")]),t._v(" "),v("h3",{attrs:{id:"socket"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#socket"}},[t._v("#")]),t._v(" socket")]),t._v(" "),v("p",[t._v("可以跨机器通信,本地可以走回环地址"),v("code",[t._v("127.0.0.1")]),t._v(",数据在协议栈转发,不会到达网卡,可以在回环网卡 lo 上抓包到.")]),t._v(" "),v("h3",{attrs:{id:"匿名管道"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#匿名管道"}},[t._v("#")]),t._v(" 匿名管道")]),t._v(" "),v("p",[t._v("内核中一段缓存区,提供读写,通过 fork 创建子进程,子进程继承父进程管道信息,一个读一个写,实现通信.匿名管道是单向的,需要创建两个才可以相互读写.")]),t._v(" "),v("p",[t._v("需要有亲缘关系到进程继承后才能通信,并且重启后丢失,")]),t._v(" "),v("h3",{attrs:{id:"命名管道"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#命名管道"}},[t._v("#")]),t._v(" 命名管道")]),t._v(" "),v("p",[t._v("有了名字,不限制于亲缘关系只要有名字就可以打开管道通信.消息为二进制流.")]),t._v(" "),v("h3",{attrs:{id:"消息队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[t._v("#")]),t._v(" 消息队列")]),t._v(" "),v("p",[t._v("内核中一个消息链表,按照消息块组织,可以指定类型双向通信.")]),t._v(" "),v("h3",{attrs:{id:"共享内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#共享内存"}},[t._v("#")]),t._v(" 共享内存")]),t._v(" "),v("p",[t._v("将物理地址映射到虚拟地址,数据量大时方便共享.为了防止读写冲突需要配合信号量一起使用.")]),t._v(" "),v("h3",{attrs:{id:"信号量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#信号量"}},[t._v("#")]),t._v(" 信号量")]),t._v(" "),v("h2",{attrs:{id:"网络错误"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网络错误"}},[t._v("#")]),t._v(" 网络错误")]),t._v(" "),v("h3",{attrs:{id:"rst"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rst"}},[t._v("#")]),t._v(" rst")]),t._v(" "),v("ul",[v("li",[t._v("connection reset by peer : 应用层读数据时,内核返回连接被重置")]),t._v(" "),v("li",[t._v("broken pipe : 应用层写数据,内核返回连接已破坏,即重置")])]),t._v(" "),v("p",[t._v("listen : 会创建一个 sock 放入到全局 hash 表中,客户端发起 connect 请求服务端收到数据包后会根据 ip 和端口从 hash 表中读取 sock.如果拿不到 sock ,并且校验和通过后会发送 rst 给客户端")])])}),[],!1,null,null,null);a.default=_.exports}}]);