<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>消息队列 | 嗯哼人生</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    <meta name="referrer" content="no-referrer">
    
    <link rel="preload" href="/m/assets/css/0.styles.1e386fb6.css" as="style"><link rel="preload" href="/m/assets/js/app.71fdaff2.js" as="script"><link rel="preload" href="/m/assets/js/2.351ead77.js" as="script"><link rel="preload" href="/m/assets/js/10.98c1e7e0.js" as="script"><link rel="prefetch" href="/m/assets/js/100.d7774ae1.js"><link rel="prefetch" href="/m/assets/js/101.0d4dea0d.js"><link rel="prefetch" href="/m/assets/js/102.6867f859.js"><link rel="prefetch" href="/m/assets/js/103.9d24bd08.js"><link rel="prefetch" href="/m/assets/js/104.4d59f256.js"><link rel="prefetch" href="/m/assets/js/105.ff49af8e.js"><link rel="prefetch" href="/m/assets/js/106.b26c7611.js"><link rel="prefetch" href="/m/assets/js/107.da5be320.js"><link rel="prefetch" href="/m/assets/js/108.0c03f842.js"><link rel="prefetch" href="/m/assets/js/109.5587de24.js"><link rel="prefetch" href="/m/assets/js/11.4e6d88d4.js"><link rel="prefetch" href="/m/assets/js/110.40ae6022.js"><link rel="prefetch" href="/m/assets/js/111.0353ccf3.js"><link rel="prefetch" href="/m/assets/js/112.f562c096.js"><link rel="prefetch" href="/m/assets/js/113.7926c003.js"><link rel="prefetch" href="/m/assets/js/114.356035f0.js"><link rel="prefetch" href="/m/assets/js/115.15e5e23e.js"><link rel="prefetch" href="/m/assets/js/116.2db2b1ed.js"><link rel="prefetch" href="/m/assets/js/117.2658e42c.js"><link rel="prefetch" href="/m/assets/js/118.037a8503.js"><link rel="prefetch" href="/m/assets/js/119.21153540.js"><link rel="prefetch" href="/m/assets/js/12.c3dadd73.js"><link rel="prefetch" href="/m/assets/js/120.b8f0644f.js"><link rel="prefetch" href="/m/assets/js/121.4c1c263a.js"><link rel="prefetch" href="/m/assets/js/122.d6ba18dd.js"><link rel="prefetch" href="/m/assets/js/123.ceef4883.js"><link rel="prefetch" href="/m/assets/js/124.9e5f50ca.js"><link rel="prefetch" href="/m/assets/js/125.de1ddc80.js"><link rel="prefetch" href="/m/assets/js/126.ae350aea.js"><link rel="prefetch" href="/m/assets/js/127.4636f6be.js"><link rel="prefetch" href="/m/assets/js/128.13b379ab.js"><link rel="prefetch" href="/m/assets/js/129.e7b0a15f.js"><link rel="prefetch" href="/m/assets/js/13.a52bd89b.js"><link rel="prefetch" href="/m/assets/js/130.147cdf11.js"><link rel="prefetch" href="/m/assets/js/131.c7a07871.js"><link rel="prefetch" href="/m/assets/js/132.faf72eb9.js"><link rel="prefetch" href="/m/assets/js/133.6301923b.js"><link rel="prefetch" href="/m/assets/js/134.4357c6e4.js"><link rel="prefetch" href="/m/assets/js/135.0ea43a3d.js"><link rel="prefetch" href="/m/assets/js/136.5a7c2377.js"><link rel="prefetch" href="/m/assets/js/137.393c998e.js"><link rel="prefetch" href="/m/assets/js/138.dcf958b6.js"><link rel="prefetch" href="/m/assets/js/139.1ccac68b.js"><link rel="prefetch" href="/m/assets/js/14.96fff293.js"><link rel="prefetch" href="/m/assets/js/140.938c314e.js"><link rel="prefetch" href="/m/assets/js/141.03cc2137.js"><link rel="prefetch" href="/m/assets/js/142.db00aba9.js"><link rel="prefetch" href="/m/assets/js/143.6d7b22af.js"><link rel="prefetch" href="/m/assets/js/144.850ed5a9.js"><link rel="prefetch" href="/m/assets/js/145.a1958a5f.js"><link rel="prefetch" href="/m/assets/js/146.1b350d4f.js"><link rel="prefetch" href="/m/assets/js/147.961f3ccd.js"><link rel="prefetch" href="/m/assets/js/148.cb4f8811.js"><link rel="prefetch" href="/m/assets/js/149.45ad7c2c.js"><link rel="prefetch" href="/m/assets/js/15.c507965f.js"><link rel="prefetch" href="/m/assets/js/150.5d952b70.js"><link rel="prefetch" href="/m/assets/js/151.5c794bb0.js"><link rel="prefetch" href="/m/assets/js/152.974e657e.js"><link rel="prefetch" href="/m/assets/js/153.b7cf98f6.js"><link rel="prefetch" href="/m/assets/js/154.be904394.js"><link rel="prefetch" href="/m/assets/js/155.769e3b0d.js"><link rel="prefetch" href="/m/assets/js/156.6107a44f.js"><link rel="prefetch" href="/m/assets/js/157.0bf74a2b.js"><link rel="prefetch" href="/m/assets/js/158.d499f907.js"><link rel="prefetch" href="/m/assets/js/159.6b2acd2c.js"><link rel="prefetch" href="/m/assets/js/16.247520d0.js"><link rel="prefetch" href="/m/assets/js/160.ec909209.js"><link rel="prefetch" href="/m/assets/js/161.4832768d.js"><link rel="prefetch" href="/m/assets/js/162.ae74834a.js"><link rel="prefetch" href="/m/assets/js/163.8af51be9.js"><link rel="prefetch" href="/m/assets/js/164.0d64a1ef.js"><link rel="prefetch" href="/m/assets/js/165.5e5a775c.js"><link rel="prefetch" href="/m/assets/js/166.121987f8.js"><link rel="prefetch" href="/m/assets/js/167.1c270942.js"><link rel="prefetch" href="/m/assets/js/168.200df8c8.js"><link rel="prefetch" href="/m/assets/js/169.84f5e0d7.js"><link rel="prefetch" href="/m/assets/js/17.3cb462b5.js"><link rel="prefetch" href="/m/assets/js/170.57b7eec5.js"><link rel="prefetch" href="/m/assets/js/171.d993d636.js"><link rel="prefetch" href="/m/assets/js/172.820d00a1.js"><link rel="prefetch" href="/m/assets/js/173.cc29ff6e.js"><link rel="prefetch" href="/m/assets/js/174.99d62af7.js"><link rel="prefetch" href="/m/assets/js/175.da874148.js"><link rel="prefetch" href="/m/assets/js/176.d0755bfc.js"><link rel="prefetch" href="/m/assets/js/177.8b00d874.js"><link rel="prefetch" href="/m/assets/js/178.2b0cfda8.js"><link rel="prefetch" href="/m/assets/js/179.780a3873.js"><link rel="prefetch" href="/m/assets/js/18.298da910.js"><link rel="prefetch" href="/m/assets/js/180.7c0ac3dc.js"><link rel="prefetch" href="/m/assets/js/181.507f9073.js"><link rel="prefetch" href="/m/assets/js/182.87f76d4a.js"><link rel="prefetch" href="/m/assets/js/183.1410502e.js"><link rel="prefetch" href="/m/assets/js/184.80666cb3.js"><link rel="prefetch" href="/m/assets/js/185.dc628b97.js"><link rel="prefetch" href="/m/assets/js/186.c2560a3f.js"><link rel="prefetch" href="/m/assets/js/187.6af43ea3.js"><link rel="prefetch" href="/m/assets/js/188.da75b50c.js"><link rel="prefetch" href="/m/assets/js/189.78dd960b.js"><link rel="prefetch" href="/m/assets/js/19.d9eabdf8.js"><link rel="prefetch" href="/m/assets/js/190.017586b9.js"><link rel="prefetch" href="/m/assets/js/191.5fa65eb7.js"><link rel="prefetch" href="/m/assets/js/192.5bb628c7.js"><link rel="prefetch" href="/m/assets/js/193.35707c80.js"><link rel="prefetch" href="/m/assets/js/194.35c3b13b.js"><link rel="prefetch" href="/m/assets/js/195.6dc8874b.js"><link rel="prefetch" href="/m/assets/js/196.01a1e825.js"><link rel="prefetch" href="/m/assets/js/197.5745084a.js"><link rel="prefetch" href="/m/assets/js/198.0455ca12.js"><link rel="prefetch" href="/m/assets/js/199.75129c13.js"><link rel="prefetch" href="/m/assets/js/20.ce14ddb9.js"><link rel="prefetch" href="/m/assets/js/200.a08681d0.js"><link rel="prefetch" href="/m/assets/js/201.a54018b7.js"><link rel="prefetch" href="/m/assets/js/202.2361e839.js"><link rel="prefetch" href="/m/assets/js/203.b92491ee.js"><link rel="prefetch" href="/m/assets/js/204.13742571.js"><link rel="prefetch" href="/m/assets/js/205.b066e447.js"><link rel="prefetch" href="/m/assets/js/206.e2c72f2c.js"><link rel="prefetch" href="/m/assets/js/207.09a83a9a.js"><link rel="prefetch" href="/m/assets/js/208.f4b8d71c.js"><link rel="prefetch" href="/m/assets/js/209.1a4e4d18.js"><link rel="prefetch" href="/m/assets/js/21.0dc0e0bf.js"><link rel="prefetch" href="/m/assets/js/210.9709d46f.js"><link rel="prefetch" href="/m/assets/js/211.3704916b.js"><link rel="prefetch" href="/m/assets/js/212.7c96c99f.js"><link rel="prefetch" href="/m/assets/js/213.b4aedaa1.js"><link rel="prefetch" href="/m/assets/js/214.d0b2586b.js"><link rel="prefetch" href="/m/assets/js/215.2268650a.js"><link rel="prefetch" href="/m/assets/js/216.dcaa6f2f.js"><link rel="prefetch" href="/m/assets/js/217.33aaf649.js"><link rel="prefetch" href="/m/assets/js/218.216d8592.js"><link rel="prefetch" href="/m/assets/js/219.44d35873.js"><link rel="prefetch" href="/m/assets/js/22.ce355d8a.js"><link rel="prefetch" href="/m/assets/js/220.ff06fa11.js"><link rel="prefetch" href="/m/assets/js/221.93379b76.js"><link rel="prefetch" href="/m/assets/js/222.6f0bbeea.js"><link rel="prefetch" href="/m/assets/js/223.4c5e29f0.js"><link rel="prefetch" href="/m/assets/js/224.e7be32e4.js"><link rel="prefetch" href="/m/assets/js/225.4915db8f.js"><link rel="prefetch" href="/m/assets/js/226.60f21d11.js"><link rel="prefetch" href="/m/assets/js/227.0e63cf34.js"><link rel="prefetch" href="/m/assets/js/228.e7b7a543.js"><link rel="prefetch" href="/m/assets/js/229.73bf392a.js"><link rel="prefetch" href="/m/assets/js/23.40c917ac.js"><link rel="prefetch" href="/m/assets/js/230.9f789c55.js"><link rel="prefetch" href="/m/assets/js/231.8fd85bc2.js"><link rel="prefetch" href="/m/assets/js/232.e6c4a62c.js"><link rel="prefetch" href="/m/assets/js/233.45636bf3.js"><link rel="prefetch" href="/m/assets/js/234.5194ce16.js"><link rel="prefetch" href="/m/assets/js/235.15ba019b.js"><link rel="prefetch" href="/m/assets/js/236.ac5768c1.js"><link rel="prefetch" href="/m/assets/js/237.91ec2e5a.js"><link rel="prefetch" href="/m/assets/js/238.af630344.js"><link rel="prefetch" href="/m/assets/js/239.b2b84093.js"><link rel="prefetch" href="/m/assets/js/24.5b681006.js"><link rel="prefetch" href="/m/assets/js/240.9c9b1fba.js"><link rel="prefetch" href="/m/assets/js/241.c26c2147.js"><link rel="prefetch" href="/m/assets/js/242.ce44f37f.js"><link rel="prefetch" href="/m/assets/js/243.aa04b829.js"><link rel="prefetch" href="/m/assets/js/244.ee4c9090.js"><link rel="prefetch" href="/m/assets/js/245.62ebda1d.js"><link rel="prefetch" href="/m/assets/js/246.2fd9ce22.js"><link rel="prefetch" href="/m/assets/js/247.52b3e746.js"><link rel="prefetch" href="/m/assets/js/248.2e432a32.js"><link rel="prefetch" href="/m/assets/js/249.4598fccb.js"><link rel="prefetch" href="/m/assets/js/25.d5d6ba55.js"><link rel="prefetch" href="/m/assets/js/250.7c93bc3e.js"><link rel="prefetch" href="/m/assets/js/251.4d402930.js"><link rel="prefetch" href="/m/assets/js/252.1b3fb775.js"><link rel="prefetch" href="/m/assets/js/253.01a9b4f8.js"><link rel="prefetch" href="/m/assets/js/254.29de4256.js"><link rel="prefetch" href="/m/assets/js/255.4911ce12.js"><link rel="prefetch" href="/m/assets/js/256.0a40f8d2.js"><link rel="prefetch" href="/m/assets/js/257.2111ae5e.js"><link rel="prefetch" href="/m/assets/js/258.0e9b2cd1.js"><link rel="prefetch" href="/m/assets/js/259.43158d35.js"><link rel="prefetch" href="/m/assets/js/26.b1e00e8a.js"><link rel="prefetch" href="/m/assets/js/260.72ea8c45.js"><link rel="prefetch" href="/m/assets/js/261.3f679643.js"><link rel="prefetch" href="/m/assets/js/262.d9ecaed6.js"><link rel="prefetch" href="/m/assets/js/27.556976c4.js"><link rel="prefetch" href="/m/assets/js/28.11027d56.js"><link rel="prefetch" href="/m/assets/js/29.f40ac6f5.js"><link rel="prefetch" href="/m/assets/js/3.a2a1a8e5.js"><link rel="prefetch" href="/m/assets/js/30.3b59bb10.js"><link rel="prefetch" href="/m/assets/js/31.c37142be.js"><link rel="prefetch" href="/m/assets/js/32.c5e0d2a0.js"><link rel="prefetch" href="/m/assets/js/33.4f5f3a8d.js"><link rel="prefetch" href="/m/assets/js/34.4a3a9398.js"><link rel="prefetch" href="/m/assets/js/35.77f89f97.js"><link rel="prefetch" href="/m/assets/js/36.6ea00d3c.js"><link rel="prefetch" href="/m/assets/js/37.b5a3b5b4.js"><link rel="prefetch" href="/m/assets/js/38.24b26621.js"><link rel="prefetch" href="/m/assets/js/39.ab372876.js"><link rel="prefetch" href="/m/assets/js/4.b9f14f77.js"><link rel="prefetch" href="/m/assets/js/40.7a81caac.js"><link rel="prefetch" href="/m/assets/js/41.d23cf8c8.js"><link rel="prefetch" href="/m/assets/js/42.ef938986.js"><link rel="prefetch" href="/m/assets/js/43.708a3cf3.js"><link rel="prefetch" href="/m/assets/js/44.f705f7de.js"><link rel="prefetch" href="/m/assets/js/45.0e6afdb6.js"><link rel="prefetch" href="/m/assets/js/46.9815c7cc.js"><link rel="prefetch" href="/m/assets/js/47.5d1c1dcc.js"><link rel="prefetch" href="/m/assets/js/48.d9d571a6.js"><link rel="prefetch" href="/m/assets/js/49.9cbaa1e9.js"><link rel="prefetch" href="/m/assets/js/5.57dbdc35.js"><link rel="prefetch" href="/m/assets/js/50.265f94f4.js"><link rel="prefetch" href="/m/assets/js/51.094b2e7f.js"><link rel="prefetch" href="/m/assets/js/52.8b7101c0.js"><link rel="prefetch" href="/m/assets/js/53.98f3fc0b.js"><link rel="prefetch" href="/m/assets/js/54.b3d830fd.js"><link rel="prefetch" href="/m/assets/js/55.fb9cd8c7.js"><link rel="prefetch" href="/m/assets/js/56.878cf94b.js"><link rel="prefetch" href="/m/assets/js/57.1c819831.js"><link rel="prefetch" href="/m/assets/js/58.ac3faf70.js"><link rel="prefetch" href="/m/assets/js/59.b0483bf9.js"><link rel="prefetch" href="/m/assets/js/6.a0c51186.js"><link rel="prefetch" href="/m/assets/js/60.48c301e6.js"><link rel="prefetch" href="/m/assets/js/61.4bf4f2e7.js"><link rel="prefetch" href="/m/assets/js/62.d927584b.js"><link rel="prefetch" href="/m/assets/js/63.b72a48f3.js"><link rel="prefetch" href="/m/assets/js/64.6923d7c8.js"><link rel="prefetch" href="/m/assets/js/65.042fc335.js"><link rel="prefetch" href="/m/assets/js/66.1afdb278.js"><link rel="prefetch" href="/m/assets/js/67.04f7b0c7.js"><link rel="prefetch" href="/m/assets/js/68.97789db4.js"><link rel="prefetch" href="/m/assets/js/69.d914e9f8.js"><link rel="prefetch" href="/m/assets/js/7.aef5e50f.js"><link rel="prefetch" href="/m/assets/js/70.84845956.js"><link rel="prefetch" href="/m/assets/js/71.d6e9132a.js"><link rel="prefetch" href="/m/assets/js/72.2c1f5783.js"><link rel="prefetch" href="/m/assets/js/73.789e9372.js"><link rel="prefetch" href="/m/assets/js/74.e79f4842.js"><link rel="prefetch" href="/m/assets/js/75.4a389066.js"><link rel="prefetch" href="/m/assets/js/76.f5721f28.js"><link rel="prefetch" href="/m/assets/js/77.e6ce992d.js"><link rel="prefetch" href="/m/assets/js/78.5c31237a.js"><link rel="prefetch" href="/m/assets/js/79.6a4f09e0.js"><link rel="prefetch" href="/m/assets/js/8.aac4a85a.js"><link rel="prefetch" href="/m/assets/js/80.23b925ca.js"><link rel="prefetch" href="/m/assets/js/81.bc8138cb.js"><link rel="prefetch" href="/m/assets/js/82.4783bc83.js"><link rel="prefetch" href="/m/assets/js/83.1be8f057.js"><link rel="prefetch" href="/m/assets/js/84.3132660e.js"><link rel="prefetch" href="/m/assets/js/85.95c5ab8b.js"><link rel="prefetch" href="/m/assets/js/86.17c9a201.js"><link rel="prefetch" href="/m/assets/js/87.daa0da6b.js"><link rel="prefetch" href="/m/assets/js/88.9409cacc.js"><link rel="prefetch" href="/m/assets/js/89.bf04eaa0.js"><link rel="prefetch" href="/m/assets/js/9.0dd0ff11.js"><link rel="prefetch" href="/m/assets/js/90.5e1e2630.js"><link rel="prefetch" href="/m/assets/js/91.6466b581.js"><link rel="prefetch" href="/m/assets/js/92.0dd7ffc6.js"><link rel="prefetch" href="/m/assets/js/93.045047c7.js"><link rel="prefetch" href="/m/assets/js/94.ce06dedb.js"><link rel="prefetch" href="/m/assets/js/95.f673ef28.js"><link rel="prefetch" href="/m/assets/js/96.1f73d13d.js"><link rel="prefetch" href="/m/assets/js/97.b1800fdc.js"><link rel="prefetch" href="/m/assets/js/98.245eb5e4.js"><link rel="prefetch" href="/m/assets/js/99.2cfc78a1.js">
    <link rel="stylesheet" href="/m/assets/css/0.styles.1e386fb6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/m/" class="home-link router-link-active"><!----> <span class="site-name">嗯哼人生</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/m/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://cn100800.tk" target="_blank" rel="noopener noreferrer" class="nav-link external">
  主站
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="mailto:freecracy1024@gmail.com" class="nav-link external">
  mail
  <!----></a></div><div class="nav-item"><a href="https://google.com.hk" target="_blank" rel="noopener noreferrer" class="nav-link external">
  google
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/m/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="https://cn100800.tk" target="_blank" rel="noopener noreferrer" class="nav-link external">
  主站
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="mailto:freecracy1024@gmail.com" class="nav-link external">
  mail
  <!----></a></div><div class="nav-item"><a href="https://google.com.hk" target="_blank" rel="noopener noreferrer" class="nav-link external">
  google
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Go语言之旅</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Deno</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>其他</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>周末闲谈</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>深度好文</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>漫步 Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>设计模式</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/m/设计模式/分库分表.html" class="sidebar-link">分库分表</a></li><li><a href="/m/设计模式/ES.html" class="sidebar-link">ES</a></li><li><a href="/m/设计模式/多账号登录.html" class="sidebar-link">多账户统一登录</a></li><li><a href="/m/设计模式/IM.html" class="sidebar-link">IM即时通信</a></li><li><a href="/m/设计模式/GraphQL.html" class="sidebar-link">GraphQL</a></li><li><a href="/m/设计模式/常用命令.html" class="sidebar-link">常用命令</a></li><li><a href="/m/设计模式/OAuth2.html" class="sidebar-link">OAuth2.0</a></li><li><a href="/m/设计模式/IO模型.html" class="sidebar-link">IO模型</a></li><li><a href="/m/设计模式/MySQL.html" class="sidebar-link">MySQL</a></li><li><a href="/m/设计模式/搜索引擎.html" class="sidebar-link">搜索引擎</a></li><li><a href="/m/设计模式/feed流.html" class="sidebar-link">feed流</a></li><li><a href="/m/设计模式/PHP.html" class="sidebar-link">PHP</a></li><li><a href="/m/设计模式/Rust.html" class="sidebar-link">Rust</a></li><li><a href="/m/设计模式/WebSocket.html" class="sidebar-link">Websocket</a></li><li><a href="/m/设计模式/注册中心.html" class="sidebar-link">注册中心</a></li><li><a href="/m/设计模式/web.html" class="sidebar-link">HTTPS</a></li><li><a href="/m/设计模式/k8s.html" class="sidebar-link">k8s</a></li><li><a href="/m/设计模式/vue.html" class="sidebar-link">vue</a></li><li><a href="/m/设计模式/lua.html" class="sidebar-link">lua</a></li><li><a href="/m/设计模式/leader.html" class="sidebar-link">leader</a></li><li><a href="/m/设计模式/热门搜索字符串.html" class="sidebar-link">热门搜索字符串</a></li><li><a href="/m/设计模式/延时消息.html" class="sidebar-link">延时消息</a></li><li><a href="/m/设计模式/分布式事务.html" class="sidebar-link">分布式事务</a></li><li><a href="/m/设计模式/再谈架构.html" class="sidebar-link">再谈架构</a></li><li><a href="/m/设计模式/日志监控.html" class="sidebar-link">日志监控</a></li><li><a href="/m/设计模式/权限系统.html" class="sidebar-link">权限系统</a></li><li><a href="/m/设计模式/消息队列.html" class="active sidebar-link">消息队列</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/m/设计模式/消息队列.html#比较" class="sidebar-link">比较</a></li><li class="sidebar-sub-header"><a href="/m/设计模式/消息队列.html#rocketmq" class="sidebar-link">RocketMQ</a></li><li class="sidebar-sub-header"><a href="/m/设计模式/消息队列.html#rabbitmq" class="sidebar-link">RabbitMQ</a></li><li class="sidebar-sub-header"><a href="/m/设计模式/消息队列.html#rocketmq-2" class="sidebar-link">RocketMQ</a></li><li class="sidebar-sub-header"><a href="/m/设计模式/消息队列.html#kafka" class="sidebar-link">kafka</a></li><li class="sidebar-sub-header"><a href="/m/设计模式/消息队列.html#zk" class="sidebar-link">zk</a></li><li class="sidebar-sub-header"><a href="/m/设计模式/消息队列.html#异步消息乱序" class="sidebar-link">异步消息乱序</a></li><li class="sidebar-sub-header"><a href="/m/设计模式/消息队列.html#使用场景" class="sidebar-link">使用场景</a></li><li class="sidebar-sub-header"><a href="/m/设计模式/消息队列.html#kafka长轮询" class="sidebar-link">kafka长轮询</a></li><li class="sidebar-sub-header"><a href="/m/设计模式/消息队列.html#rocketmq-3" class="sidebar-link">RocketMQ</a></li><li class="sidebar-sub-header"><a href="/m/设计模式/消息队列.html#消息队列-2" class="sidebar-link">消息队列</a></li><li class="sidebar-sub-header"><a href="/m/设计模式/消息队列.html#消息队列-3" class="sidebar-link">消息队列</a></li><li class="sidebar-sub-header"><a href="/m/设计模式/消息队列.html#kafka配置文件" class="sidebar-link">kafka配置文件</a></li><li class="sidebar-sub-header"><a href="/m/设计模式/消息队列.html#kafka-2" class="sidebar-link">kafka</a></li><li class="sidebar-sub-header"><a href="/m/设计模式/消息队列.html#pulsar" class="sidebar-link">pulsar</a></li></ul></li><li><a href="/m/设计模式/点赞签到.html" class="sidebar-link">点赞签到</a></li><li><a href="/m/设计模式/用户排名.html" class="sidebar-link">用户排名</a></li><li><a href="/m/设计模式/电商系统.html" class="sidebar-link">电商系统</a></li><li><a href="/m/设计模式/直播.html" class="sidebar-link">直播</a></li><li><a href="/m/设计模式/秒杀抢购.html" class="sidebar-link">秒杀抢购</a></li><li><a href="/m/设计模式/设计模式.html" class="sidebar-link">设计模式</a></li><li><a href="/m/设计模式/通用型系统设计.html" class="sidebar-link">通用型系统设计</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>鸡汤软文</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="消息队列"><a href="#消息队列" class="header-anchor">#</a> 消息队列</h1> <h2 id="比较"><a href="#比较" class="header-anchor">#</a> 比较</h2> <table><thead><tr><th>MQ</th> <th>ActiveMQ</th> <th>RabbitMQ</th> <th>RocketMQ</th> <th>kafka</th></tr></thead> <tbody><tr><td>语言</td> <td>java</td> <td>rtlang</td> <td>java</td> <td>java</td></tr> <tr><td>社区</td> <td></td> <td></td> <td>阿里(捐赠 apache)</td> <td></td></tr> <tr><td>界面</td> <td>web</td> <td>web</td> <td>只有命令行</td> <td>web</td></tr> <tr><td>延迟</td> <td>毫秒</td> <td>微妙</td> <td>毫秒</td> <td>毫秒</td></tr> <tr><td>吞吐量</td> <td>w</td> <td>w</td> <td>10w</td> <td>10w</td></tr></tbody></table> <h2 id="rocketmq"><a href="#rocketmq" class="header-anchor">#</a> RocketMQ</h2> <h3 id="概念"><a href="#概念" class="header-anchor">#</a> 概念</h3> <p>topic、生产者、消费者、消息、group 同 kafka,自己实现了服务发现服务 namesrv.</p> <h3 id="作用"><a href="#作用" class="header-anchor">#</a> 作用</h3> <p>异步、解藕、削峰填谷、分布式事务最终一致性、数据分发(比如 binlog)</p> <h3 id="组件"><a href="#组件" class="header-anchor">#</a> 组件</h3> <p><img src="/m/assets/img/rocketMQ-zucheng.66241d46.png" alt="rocketMQ-zucheng"></p> <ol><li>name server : 无状态节点,可集群部署,此处提供命名服务,更新和发现 broker 服务,本质是一个注册中心.</li> <li>broker : 消息中转角色,负责存储转发消息,分为 master 和 slave,启动时将自己注册到 name server,之后每 30s 向 name server 上报 topic 路由信息.</li> <li>生产者 : 与 name server 集群中随机一个节点建立长连接(keep-alive),定期从 name server 读取 topic 路由信息,并向提供 topic 服务的 master broker 建立长连接,且定时向 master broker 发送心跳.</li> <li>消费者 : 与 name server 集群中随机一个节点建立长连接,定期从 name server 拉取 topic 路由信息,并向提供 topic 服务的 master broker、slave broker 建立长连接,且定时向 master broker、slave broker 发送心跳.消费者既可以从 master broker 订阅消息,也可以从 slave broker 订阅消息,订阅规则由 broker 配置决定.</li></ol> <h3 id="消息类型"><a href="#消息类型" class="header-anchor">#</a> 消息类型</h3> <ol><li>普通消息
<ul><li>同步发送 : 消息发送方发出一条消息,会同步得到服务端返回结果</li> <li>异步发送 : 消息发送方发出一条消息不用等待服务端返回结果,接着发送下一条消息,发送方可以通过回调接口接收服务端响应</li> <li>单向发送 : 消息发送方只负责发送消息,发送消息快,存在丢失消息风险</li></ul></li> <li>顺序消息</li> <li>定时消息(延迟消息) : 消费发送到服务端后,不会立即投递给消费者,而是等到消息指定的时间后才会投递消费者进行消费,延迟消息一般是在当前发送时间的基础上延迟多久发送.</li> <li>事务消息</li></ol> <h3 id="事务消息"><a href="#事务消息" class="header-anchor">#</a> 事务消息</h3> <p>两阶段提交结合消息反查机制确保最终一致性.</p> <ol><li>发送方发送半事务消息到服务端</li> <li>服务端接收消息后,消息持久化成功,向发送方返回 ack 确认消息已经发送成功,此时消息为半事务消息,不会投递给消费方</li> <li>收到半事务消息的 ack 后,发送方开始执行本地事务逻辑</li> <li>发送方根据本地事务执行结果向服务端提交二次确认,如果本地事务执行成功则进行消息的 commit,如果执行失败则进行消息的 rollback,服务端收到 commit 状态则将半事务消息标记为可投递,服务端收到 rollback 状态则删除半事务消息.</li> <li>如果没有进行消息的二次确认,等待固定时间后服务端将对消息发起消息回查</li> <li>发送方收到消息回查后需要检查对应消息本地事务执行结果.根据检查到的本地事务的最终状态再次提交二次确认.</li></ol> <h3 id="消息重试"><a href="#消息重试" class="header-anchor">#</a> 消息重试</h3> <p>消息在消费方消费失败后,服务端会重新投递消息,直到消费者成功消费消息,默认重试 16 次.</p> <h3 id="消息过滤"><a href="#消息过滤" class="header-anchor">#</a> 消息过滤</h3> <p>可以给消息指定 tag,通过 tag 来区分消息类型,消费者可以根据 tag 在服务端完成消息过滤,确保消费者最终只能消费到其关注的消息.</p> <h3 id="消费模式"><a href="#消费模式" class="header-anchor">#</a> 消费模式</h3> <ol><li>集群消费 : 消息只允许被消费一次</li> <li>广播消费 : 会让每个消费者都消费一次,如使用了本地缓存,当数据变更时需要刷新每个节点本地缓存.</li></ol> <h3 id="消息幂等"><a href="#消息幂等" class="header-anchor">#</a> 消息幂等</h3> <p>最佳的幂等处理方式需要唯一业务标识,在发送消息时可以为每个消息设置一个 key 用来做业务的唯一标识.</p> <h3 id="本地事务消息封装"><a href="#本地事务消息封装" class="header-anchor">#</a> 本地事务消息封装</h3> <p>如果每个业务场景都去实现一个反查逻辑,不易使用.本地事务消息表,本地事务消息需要在服务对应数据库创建一个消息表,发送消息时不是真正把消息发送给 MQ,而是往消息表中插入一条消息数据.插入动作跟本地业务逻辑是同一个事务,如果本地事务执行成功,消息才会落表成功,才会发送给 MQ,本地事务失败消息回滚.然后启动一个专门的线程去拉取消息表中未发送的消息投递给 MQ,如果投递失败可以一直重试,直到成功或者人工介入.</p> <p>消息写到消息表,然后一直给 MQ 发送,不会有问题,如果 MQ 收到消息消息还在 pagecache 中 broker 宕机了,会出现消息丢失,当然可以使用同步刷盘避免丢失.在消息表中标记未发送、已发送、已消费.当消息还是未发送的时候就会被发送到 MQ,如果发送成功了,状态就是已发送,如果发送成功了状态就是已发送,但是几分钟后状态还是已发送就知道消息丢失或者消费速度跟不上生产速度,消息堆积了.</p> <h3 id="死信队列"><a href="#死信队列" class="header-anchor">#</a> 死信队列</h3> <h2 id="rabbitmq"><a href="#rabbitmq" class="header-anchor">#</a> RabbitMQ</h2> <p>一个erlang开发的MQ,一个队列,消息确认后删除,开发者定义命名队列,发布者可以向队列发送消息,消费者通过命名队列消费消息.使用消息交换器来实现发布订阅,发布者将消息发布到消息交换器上,不用知道有哪些订阅者.每一个订阅了交换器的消费者都会创建一个队列,消息交换器会把生产的消息放入队列,供消费者消费,消息交换器也可以基于路由规则为订阅者过滤消息.RabbitMQ支持临时和持久两种订阅类型.消费者也可以分订阅者组消费.</p> <p><img src="/m/assets/img/RabbitMQ.8b0e7961.png" alt="RabbitMQ"></p> <p>当一个消息没有任何消费者消费就会成为死信,被重新 push 到另一个 exchange.这个 exchange 就是死信队列.通过 exchange 将消息发送到多个队列可以使一条消息被多个消费者消费.</p> <h3 id="集群模式"><a href="#集群模式" class="header-anchor">#</a> 集群模式</h3> <ol><li>主备模式 : 从节点不提供任何读写服务,只做备份,主宕机备会自动切换主节点.(区别主从,主提供写从提供读)</li> <li>集群模式 : 镜像队列,多活模式</li></ol> <h2 id="rocketmq-2"><a href="#rocketmq-2" class="header-anchor">#</a> RocketMQ</h2> <p>阿里开源,支持事务消息</p> <h3 id="事务消息-2"><a href="#事务消息-2" class="header-anchor">#</a> 事务消息</h3> <ol><li>发送半消息(发送到消息队列,但是不投递,不能被消费)</li> <li>执行本地事务</li> <li>发送commit或rollback</li> <li>提供回查接口(commit、rollback失败或丢失后回查) : 业务侵入(解决方法,封装客户端本地增加事务消息表,定期扫库发送和清理,优化写库完成后直接在内存中投递消息)</li></ol> <h2 id="kafka"><a href="#kafka" class="header-anchor">#</a> kafka</h2> <ol><li>producer</li> <li>broker</li> <li>topic</li> <li>partition : partition 的表现形式就是一个一个文件夹</li> <li>replication</li> <li>consumer : 如果消费者大于 partition 数量,多出来的消费者不消费任何数据</li> <li>consumer group : 一个分区的数据只能被消费者组中某一个消费者消费,同一个消费者组的消费者可以消费同一个 topic 不同分区的数据</li></ol> <p>是一种分布式流系统,一般做MQ使用,是根据预先配置好的时间来保留分区中的消息,而不是根据消费者是否消费了这些消息.保留机制可以使消费者自由重读之前的消息.同过删除 partition 下的 segment 来删除消息.</p> <p>持久订阅 : 在重启之后不会丢失偏移</p> <p>临时订阅 : 重启后丢失偏移并且每次重启之后都会从分区中最新记录开始读取</p> <h3 id="消费流程"><a href="#消费流程" class="header-anchor">#</a> 消费流程</h3> <ol><li>producer 先从集群获取分区的 leader</li> <li>producer 将消息发送给 leader</li> <li>leader 将消息写入本地文件</li> <li>followers 从 leader pull 消息</li> <li>followers 将消息写入本地后向 leader 发送 ack</li> <li>leader 收到所有副本的 ack 后向 producer 发送 ack</li></ol> <h3 id="为什么副本不提供读写"><a href="#为什么副本不提供读写" class="header-anchor">#</a> 为什么副本不提供读写</h3> <p>partition 和 消费组已经可以做到并发了.不需要副本增加复杂性.</p> <h3 id="isr"><a href="#isr" class="header-anchor">#</a> ISR</h3> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>replica.lag.max.message <span class="token comment"># 同步副本锁能落后的最大消息数,当副本的最大偏移量落后 leader 大于该值时就认为该副本不同步了.会从 ISR 移除,如果设置过小,会导致 follower 经常被提出 ISR,如果设置过大,则 leader 宕机会造成过多消息丢失.</span>
replica.lag.time.ms <span class="token comment"># 默认 10s, 当 follower 超过时间没有发送 fetch 请求同步 leader 时就会认为不同步而被踢出 ISR.从时间维度避免生产者发送大量消息到 leader 导致 ISR 频繁收缩和扩张问题.</span>
unclean.leader.election.enable <span class="token boolean">true</span> <span class="token comment"># 当 isr 为空,没有同步副本,leader 也挂了,允许非同步副本选出新 leader,提高可用性,但会造成消息丢失.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>leo 记录了日志的下一条消息偏移量</li> <li>HW(保证消息一致性) 界定了消费者可见的消息.消费者可以消费小于 HW 的消息,而大于 HW 的消息将无法消费. HW 一定小于 LEO.消息被同步副本同步完成后才让消息可被消费.</li></ul> <p>每个副本中都存有 LEO 和 HW.而 leader 副本中除了存储自身的 LEO 和 HW,还存储了其它 follower 的 LEO 和 HW,leader 需要保证 HW 是所有 ISR 副本集合中 LEO 最小的值.follwer 副本拉取消息后会用当前偏移量 +1 来更新 LEO,同时更新 leader 上该 follwer 的 LEO. 用 leader 的 HW 值和当前 LEO 的最小值来更新 HW.follwer 收到消息后 LEO+1, 取 LEO 和 ISR 副本中 LEO 的最小值更新 HW.</p> <h3 id="leader-epoch-checkpoint-文件"><a href="#leader-epoch-checkpoint-文件" class="header-anchor">#</a> leader-epoch-checkpoint 文件</h3> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>版本号1 offset1
版本号2 offset2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>每个副本日志目录下都有一个<code>leader-epoch-checkpoint</code>文件,保存 leader epoch 信息.包括 版本号,递增正整数,每次 leader 变更都会加 1.和一个 startoffset 为每一个版本 leader 写入的第一条消息的位移.</p> <h3 id="分区划分"><a href="#分区划分" class="header-anchor">#</a> 分区划分</h3> <ol><li>如果指定了某个 partition 则写入</li> <li>如果没指定 partition,但是设置了数据的 key,则根据 key 的值 hash 出一个 partition</li> <li>如果没指定 partition,又没有设置 key,则轮询出一个 partition</li></ol> <h3 id="如何保证数据不丢失"><a href="#如何保证数据不丢失" class="header-anchor">#</a> 如何保证数据不丢失</h3> <p>通过 ack 机制保证数据不丢失</p> <table><thead><tr><th>值</th> <th>描述</th> <th>默认</th></tr></thead> <tbody><tr><td>0</td> <td>不需要等到集群返回,不确保消息发送成功</td> <td>默认</td></tr> <tr><td>1</td> <td>只要 leader 写入成功</td> <td></td></tr> <tr><td>all</td> <td>所有 follower 都同步完成</td> <td></td></tr></tbody></table> <h3 id="kafka消息组成"><a href="#kafka消息组成" class="header-anchor">#</a> kafka消息组成</h3> <ol><li>offset : 偏移量,占 8 个字节</li> <li>size : 消息长度,占 4 个字节描述消息大小</li> <li>message : key、value、key-length、value-length、crc(消息校验)、attribute(消息属性)</li></ol> <h3 id="存储策略"><a href="#存储策略" class="header-anchor">#</a> 存储策略</h3> <p>无论消息是否被消费,都会保存所有消息.</p> <ol><li>基于时间,默认 168 小时(7 天)</li> <li>基于大小</li></ol> <h3 id="查找数据"><a href="#查找数据" class="header-anchor">#</a> 查找数据</h3> <p>segment + offset</p> <ol><li>先找到 offset 所在的 segment 文件(二分查找)</li> <li>打开着到的 segment 的 index (存储 offset 对应 message 的物理偏移量) 计算相对 offset</li> <li>找到物理偏移量,打开数据文件,扫描 message</li></ol> <h3 id="元数据"><a href="#元数据" class="header-anchor">#</a> 元数据</h3> <p>新版本中消费者消费到的 offset 直接维护在 __consumer_offsets topic 中,逐渐放弃 zk.</p> <h3 id="mmap"><a href="#mmap" class="header-anchor">#</a> mmap</h3> <p>文件映射,系统向操作内存一样操作文件.<code>producer.type</code>控制是不是主动 flush , 如果写入 mmap 立即 flush 然后返回则是同步,如果写入 mmap 后不调用 flush 则是异步(async), kafka 默认同步(sync), 虚拟内存直接映射到页缓存上,不需要从内核空间拷贝到用户空间再读取.</p> <h3 id="零拷贝"><a href="#零拷贝" class="header-anchor">#</a> 零拷贝</h3> <p>数据在内核实现输入输出.不需要拷贝到用户空间,sendfile 和 mmap 都是零拷贝到实现.</p> <p>sendfile : 将页缓存数据直接拷贝到网卡相比 read + write 和 mmap + write 少了上下文和数据拷贝.</p> <h2 id="zk"><a href="#zk" class="header-anchor">#</a> zk</h2> <table><thead><tr><th>角色</th> <th>作用</th></tr></thead> <tbody><tr><td>leader</td> <td>提供读写功能,负责将数据同步其他节点</td></tr> <tr><td>follower</td> <td>提供读功能,写请求转发 leader 处理,leader 宕机后参与 leader 选举</td></tr> <tr><td>observer</td> <td>与 follower 不同的是不参与选举</td></tr> <tr><td>looking</td> <td>节点认为集群没有 leader 会进入 looking 状态,目的是查找或选举 leader</td></tr></tbody></table> <table><thead><tr><th>zab状态</th> <th>作用</th></tr></thead> <tbody><tr><td>election</td> <td>选举状态,会选举一个 leader</td></tr> <tr><td>discovery</td> <td>响应 leader 心跳,检查 leader 是否修改,通过该步后选举的 leader 才能真正提供服务</td></tr> <tr><td>synchroniztion</td> <td>整个集群都确认 leader 后将会把 leader 数据同步所有节点</td></tr> <tr><td>broadcast</td> <td>广播状态,集群开始对外提供服务</td></tr></tbody></table> <p>zxid : long(64) 位整数,分为纪元部分(当前属于哪个 leader 或者任期)和计数器部分,是一个全局有序数字,选举时先比较纪元然后比较 zxid 如果都相等则比较 serveid,配置集群时可以把性能好的 serveid 配置大些.</p> <h3 id="zk-2"><a href="#zk-2" class="header-anchor">#</a> zk</h3> <p>broker 发现、生产者发现、消费者发现、下线、controller 注册,旧版本存储消费者的 offset.</p> <h2 id="异步消息乱序"><a href="#异步消息乱序" class="header-anchor">#</a> 异步消息乱序</h2> <h2 id="使用场景"><a href="#使用场景" class="header-anchor">#</a> 使用场景</h2> <ol><li>多个定时任务</li> <li>上游不关心下游执行结果</li> <li>上游关心执行结果但是但是执行时间很长</li></ol> <h3 id="reactor网络线程模型"><a href="#reactor网络线程模型" class="header-anchor">#</a> reactor网络线程模型</h3> <p><img src="/m/assets/img/kafka-reactor.54e35ed9.png" alt="kafka-reactor"></p> <p>客户端发送请求给 Acceptor , Acceptor 不会对处理请求,直接封装成 socketChannel 轮询发给 processor 线程(默认3个) 形成队列. io 线程池(默认8个)负责处理 request, 如果是写就写入磁盘,如果是读就返回结果, processor 会从response 中读取形影再返回给客户端.</p> <h2 id="kafka长轮询"><a href="#kafka长轮询" class="header-anchor">#</a> kafka长轮询</h2> <p>在拉请求中有参数可以使消费者请求在长轮询中阻塞等待,消费者去 broker 拉消息,定义了一个超时时间如果有消息马上返回,如果没有消费者等着直到超时然后再发起拉消息请求.borker端如果请求过来有消息马上返回没消息就建立一个延迟操作等条件满足了再返回.</p> <h2 id="rocketmq-3"><a href="#rocketmq-3" class="header-anchor">#</a> RocketMQ</h2> <p>将消息存入一个文件中,而 kafka 是将消息分 partition 存储.</p> <h2 id="消息队列-2"><a href="#消息队列-2" class="header-anchor">#</a> 消息队列</h2> <p><img src="/m/assets/img/xiaoxiduilie.23359fa0.png" alt="xiaoxiduilie"></p> <p>队列模型、和发布订阅模型 : 队列模型每条消息只能被一个消费者消费,发布订阅模型可以让一条消息被多个消费者消费,队列模型可以通过消息全量存储到多个队列解决一条消息被多个消费者消费的问题,</p> <h3 id="可靠"><a href="#可靠" class="header-anchor">#</a> 可靠</h3> <p>生产者需要处理 broker 响应出错要重试、报警等,broker 要控制响应时机单机情况下刷盘返回响应,集群多副本时至少发送两个副本再返回响应,消费这需要真正执行完业务逻辑后再返回给 broker.</p> <h3 id="重复"><a href="#重复" class="header-anchor">#</a> 重复</h3> <p>下游幂等</p> <h3 id="幂等"><a href="#幂等" class="header-anchor">#</a> 幂等</h3> <p>乐观锁,前置条件判断版本号、数据库唯一键、唯一ID等</p> <h3 id="有序"><a href="#有序" class="header-anchor">#</a> 有序</h3> <p>全局有序、局部有序</p> <h2 id="消息队列-3"><a href="#消息队列-3" class="header-anchor">#</a> 消息队列</h2> <ol><li>确认</li> <li>重传</li> <li>幂等 : 去重,检查序列号 n 是否已经被处理</li> <li>顺序 : 如果收到的消息序列号不连续,接收方可以将其放入重新排序缓存区</li></ol> <h3 id="如何保证消息必达"><a href="#如何保证消息必达" class="header-anchor">#</a> 如何保证消息必达</h3> <ol><li>消息落地</li> <li>超时、重传、确认</li></ol> <h3 id="如何保证幂等性"><a href="#如何保证幂等性" class="header-anchor">#</a> 如何保证幂等性</h3> <h3 id="发送端到-server-的幂等"><a href="#发送端到-server-的幂等" class="header-anchor">#</a> 发送端到 server 的幂等</h3> <ol><li>发送端将消息发送给服务端</li> <li>服务端将消息落地</li> <li>服务端回 ack 给发送端</li></ol> <p>如果 3 丢失,发送端会超时重发, 为了避免 2 落地重复消息,消息内部生成唯一 ID (全局唯一,MQ 生成,具备业务无关性,对发送方和接收方屏蔽)作为去重和幂等依据.</p> <h3 id="server-到接收端端幂等"><a href="#server-到接收端端幂等" class="header-anchor">#</a> server 到接收端端幂等</h3> <ol><li>服务端将消息发送给接收端</li> <li>接收端回 ack 给服务端</li> <li>服务端将落地消息删除</li></ol> <p>如果 2 丢失,可能回超时重发,导致接收方即业务方重复消费,为保证业务幂等性,消息体中必须有一个 biz_id (同一业务场景全局唯一、由业务发送方生成,业务相关,对 MQ 透明、由业务消费方负责判重,保证幂等),有了业务 ID 就能保证消费业务方即使收到重复消息,也只有一条被消费.</p> <h2 id="kafka配置文件"><a href="#kafka配置文件" class="header-anchor">#</a> kafka配置文件</h2> <h3 id="producer-properties"><a href="#producer-properties" class="header-anchor">#</a> producer.properties</h3> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment">#指定kafka节点列表，用于获取metadata，不必全部指定</span>
<span class="token comment">#需要kafka的服务器地址，来获取每一个topic的分片数等元数据信息。</span>
metadata.broker.list<span class="token operator">=</span>kafka01:9092,kafka02:9092,kafka03:9092

<span class="token comment">#生产者生产的消息被发送到哪个block，需要一个分组策略。</span>
<span class="token comment">#指定分区处理类。默认kafka.producer.DefaultPartitioner，表通过key哈希到对应分区</span>
<span class="token comment">#partitioner.class=kafka.producer.DefaultPartitioner</span>

<span class="token comment">#生产者生产的消息可以通过一定的压缩策略（或者说压缩算法）来压缩。消息被压缩后发送到broker集群，#而broker集群是不会进行解压缩的，broker集群只会把消息发送到消费者集群，然后由消费者来解压缩。</span>
<span class="token comment">#是否压缩，默认0表示不压缩，1表示用gzip压缩，2表示用snappy压缩。</span>
<span class="token comment">#压缩后消息中会有头来指明消息压缩类型，故在消费者端消息解压是透明的无需指定。</span>
<span class="token comment">#文本数据会以1比10或者更高的压缩比进行压缩。</span>
compression.codec<span class="token operator">=</span>none

<span class="token comment">#指定序列化处理类，消息在网络上传输就需要序列化，它有String、数组等许多种实现。</span>
serializer.class<span class="token operator">=</span>kafka.serializer.DefaultEncoder

<span class="token comment">#如果要压缩消息，这里指定哪些topic要压缩消息，默认empty，表示不压缩。</span>
<span class="token comment">#如果上面启用了压缩，那么这里就需要设置</span>
<span class="token comment">#compressed.topics=</span>
<span class="token comment">#这是消息的确认机制，默认值是0。在面试中常被问到。</span>
<span class="token comment">#producer有个ack参数，有三个值，分别代表：</span>
<span class="token comment">#（1）不在乎是否写入成功；</span>
<span class="token comment">#（2）写入leader成功；</span>
<span class="token comment">#（3）写入leader和所有副本都成功；</span>
<span class="token comment">#要求非常可靠的话可以牺牲性能设置成最后一种。</span>
<span class="token comment">#为了保证消息不丢失，至少要设置为1，也就</span>
<span class="token comment">#是说至少保证leader将消息保存成功。</span>
<span class="token comment">#设置发送数据是否需要服务端的反馈,有三个值0,1,-1，分别代表3种状态：</span>
<span class="token comment">#0: producer不会等待broker发送ack。生产者只要把消息发送给broker之后，就认为发送成功了，这是第1种情况；</span>
<span class="token comment">#1: 当leader接收到消息之后发送ack。生产者把消息发送到broker之后，并且消息被写入到本地文件，才认为发送成功，这是第二种情况；#-1: 当所有的follower都同步消息成功后发送ack。不仅是主的分区将消息保存成功了，#而且其所有的分区的副本数也都同步好了，才会被认为发动成功，这是第3种情况。</span>
request.required.acks<span class="token operator">=</span><span class="token number">0</span>

<span class="token comment">#broker必须在该时间范围之内给出反馈，否则失败。</span>
<span class="token comment">#在向producer发送ack之前,broker允许等待的最大时间 ，如果超时,</span>
<span class="token comment">#broker将会向producer发送一个error ACK.意味着上一次消息因为某种原因</span>
<span class="token comment">#未能成功(比如follower未能同步成功)</span>
request.timeout.ms<span class="token operator">=</span><span class="token number">10000</span>

<span class="token comment">#生产者将消息发送到broker，有两种方式，一种是同步，表示生产者发送一条，broker就接收一条；#还有一种是异步，表示生产者积累到一批的消息，装到一个池子里面缓存起来，再发送给broker，#这个池子不会无限缓存消息，在下面，它分别有一个时间限制（时间阈值）和一个数量限制（数量阈值）的参数供我们来设置。#一般我们会选择异步。</span>
<span class="token comment">#同步还是异步发送消息，默认“sync”表同步，&quot;async&quot;表异步。异步可以提高发送吞吐量,#也意味着消息将会在本地buffer中,并适时批量发送，但是也可能导致丢失未发送过去的消息</span>
producer.type<span class="token operator">=</span>sync

<span class="token comment">#在async模式下,当message被缓存的时间超过此值后,将会批量发送给broker,</span>
<span class="token comment">#默认为5000ms</span>
<span class="token comment">#此值和batch.num.messages协同工作.</span>
queue.buffering.max.ms <span class="token operator">=</span> <span class="token number">5000</span>

<span class="token comment">#异步情况下，缓存中允许存放消息数量的大小。</span>
<span class="token comment">#在async模式下,producer端允许buffer的最大消息量</span>
<span class="token comment">#无论如何,producer都无法尽快的将消息发送给broker,从而导致消息在producer端大量沉积</span>
<span class="token comment">#此时,如果消息的条数达到阀值,将会导致producer端阻塞或者消息被抛弃，默认为10000条消息。</span>
queue.buffering.max.messages<span class="token operator">=</span><span class="token number">20000</span>

<span class="token comment">#如果是异步，指定每次批量发送数据量，默认为200</span>
batch.num.messages<span class="token operator">=</span><span class="token number">500</span>

<span class="token comment">#在生产端的缓冲池中，消息发送出去之后，在没有收到确认之前，该缓冲池中的消息是不能被删除的，#但是生产者一直在生产消息，这个时候缓冲池可能会被撑爆，所以这就需要有一个处理的策略。#有两种处理方式，一种是让生产者先别生产那么快，阻塞一下，等会再生产；另一种是将缓冲池中的消息清空。</span>
<span class="token comment">#当消息在producer端沉积的条数达到&quot;queue.buffering.max.meesages&quot;后阻塞一定时间后,#队列仍然没有enqueue(producer仍然没有发送出任何消息)</span>
<span class="token comment">#此时producer可以继续阻塞或者将消息抛弃,此timeout值用于控制&quot;阻塞&quot;的时间</span>
<span class="token comment">#-1: 不限制阻塞超时时间，让produce一直阻塞,这个时候消息就不会被抛弃</span>
<span class="token comment">#0: 立即清空队列,消息被抛弃</span>
queue.enqueue.timeout.ms<span class="token operator">=</span>-1


<span class="token comment">#当producer接收到error ACK,或者没有接收到ACK时,允许消息重发的次数</span>
<span class="token comment">#因为broker并没有完整的机制来避免消息重复,所以当网络异常时(比如ACK丢失)</span>
<span class="token comment">#有可能导致broker接收到重复的消息,默认值为3.</span>
message.send.max.retries<span class="token operator">=</span><span class="token number">3</span>

<span class="token comment">#producer刷新topic metada的时间间隔,producer需要知道partition leader</span>
<span class="token comment">#的位置,以及当前topic的情况</span>
<span class="token comment">#因此producer需要一个机制来获取最新的metadata,当producer遇到特定错误时,</span>
<span class="token comment">#将会立即刷新</span>
<span class="token comment">#(比如topic失效,partition丢失,leader失效等),此外也可以通过此参数来配置</span>
<span class="token comment">#额外的刷新机制，默认值600000</span>
topic.metadata.refresh.interval.ms<span class="token operator">=</span><span class="token number">60000</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br></div></div><h3 id="consumer-properties"><a href="#consumer-properties" class="header-anchor">#</a> consumer.properties</h3> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment">#指定kafka节点列表，用于获取metadata，不必全部指定</span>
<span class="token comment">#需要kafka的服务器地址，来获取每一个topic的分片数等元数据信息。</span>
metadata.broker.list<span class="token operator">=</span>kafka01:9092,kafka02:9092,kafka03:9092

<span class="token comment">#生产者生产的消息被发送到哪个block，需要一个分组策略。</span>
<span class="token comment">#指定分区处理类。默认kafka.producer.DefaultPartitioner，表通过key哈希到对应分区</span>
<span class="token comment">#partitioner.class=kafka.producer.DefaultPartitioner</span>

<span class="token comment">#生产者生产的消息可以通过一定的压缩策略（或者说压缩算法）来压缩。消息被压缩后发送到broker集群，#而broker集群是不会进行解压缩的，broker集群只会把消息发送到消费者集群，然后由消费者来解压缩。</span>
<span class="token comment">#是否压缩，默认0表示不压缩，1表示用gzip压缩，2表示用snappy压缩。</span>
<span class="token comment">#压缩后消息中会有头来指明消息压缩类型，故在消费者端消息解压是透明的无需指定。</span>
<span class="token comment">#文本数据会以1比10或者更高的压缩比进行压缩。</span>
compression.codec<span class="token operator">=</span>none

<span class="token comment">#指定序列化处理类，消息在网络上传输就需要序列化，它有String、数组等许多种实现。</span>
serializer.class<span class="token operator">=</span>kafka.serializer.DefaultEncoder

<span class="token comment">#如果要压缩消息，这里指定哪些topic要压缩消息，默认empty，表示不压缩。</span>
<span class="token comment">#如果上面启用了压缩，那么这里就需要设置</span>
<span class="token comment">#compressed.topics=</span>
<span class="token comment">#这是消息的确认机制，默认值是0。在面试中常被问到。</span>
<span class="token comment">#producer有个ack参数，有三个值，分别代表：</span>
<span class="token comment">#（1）不在乎是否写入成功；</span>
<span class="token comment">#（2）写入leader成功；</span>
<span class="token comment">#（3）写入leader和所有副本都成功；</span>
<span class="token comment">#要求非常可靠的话可以牺牲性能设置成最后一种。</span>
<span class="token comment">#为了保证消息不丢失，至少要设置为1，也就</span>
<span class="token comment">#是说至少保证leader将消息保存成功。</span>
<span class="token comment">#设置发送数据是否需要服务端的反馈,有三个值0,1,-1，分别代表3种状态：</span>
<span class="token comment">#0: producer不会等待broker发送ack。生产者只要把消息发送给broker之后，就认为发送成功了，这是第1种情况；</span>
<span class="token comment">#1: 当leader接收到消息之后发送ack。生产者把消息发送到broker之后，并且消息被写入到本地文件，才认为发送成功，这是第二种情况；#-1: 当所有的follower都同步消息成功后发送ack。不仅是主的分区将消息保存成功了，#而且其所有的分区的副本数也都同步好了，才会被认为发动成功，这是第3种情况。</span>
request.required.acks<span class="token operator">=</span><span class="token number">0</span>

<span class="token comment">#broker必须在该时间范围之内给出反馈，否则失败。</span>
<span class="token comment">#在向producer发送ack之前,broker允许等待的最大时间 ，如果超时,</span>
<span class="token comment">#broker将会向producer发送一个error ACK.意味着上一次消息因为某种原因</span>
<span class="token comment">#未能成功(比如follower未能同步成功)</span>
request.timeout.ms<span class="token operator">=</span><span class="token number">10000</span>

<span class="token comment">#生产者将消息发送到broker，有两种方式，一种是同步，表示生产者发送一条，broker就接收一条；#还有一种是异步，表示生产者积累到一批的消息，装到一个池子里面缓存起来，再发送给broker，#这个池子不会无限缓存消息，在下面，它分别有一个时间限制（时间阈值）和一个数量限制（数量阈值）的参数供我们来设置。#一般我们会选择异步。</span>
<span class="token comment">#同步还是异步发送消息，默认“sync”表同步，&quot;async&quot;表异步。异步可以提高发送吞吐量,#也意味着消息将会在本地buffer中,并适时批量发送，但是也可能导致丢失未发送过去的消息</span>
producer.type<span class="token operator">=</span>sync

<span class="token comment">#在async模式下,当message被缓存的时间超过此值后,将会批量发送给broker,</span>
<span class="token comment">#默认为5000ms</span>
<span class="token comment">#此值和batch.num.messages协同工作.</span>
queue.buffering.max.ms <span class="token operator">=</span> <span class="token number">5000</span>

<span class="token comment">#异步情况下，缓存中允许存放消息数量的大小。</span>
<span class="token comment">#在async模式下,producer端允许buffer的最大消息量</span>
<span class="token comment">#无论如何,producer都无法尽快的将消息发送给broker,从而导致消息在producer端大量沉积</span>
<span class="token comment">#此时,如果消息的条数达到阀值,将会导致producer端阻塞或者消息被抛弃，默认为10000条消息。</span>
queue.buffering.max.messages<span class="token operator">=</span><span class="token number">20000</span>

<span class="token comment">#如果是异步，指定每次批量发送数据量，默认为200</span>
batch.num.messages<span class="token operator">=</span><span class="token number">500</span>

<span class="token comment">#在生产端的缓冲池中，消息发送出去之后，在没有收到确认之前，该缓冲池中的消息是不能被删除的，#但是生产者一直在生产消息，这个时候缓冲池可能会被撑爆，所以这就需要有一个处理的策略。#有两种处理方式，一种是让生产者先别生产那么快，阻塞一下，等会再生产；另一种是将缓冲池中的消息清空。</span>
<span class="token comment">#当消息在producer端沉积的条数达到&quot;queue.buffering.max.meesages&quot;后阻塞一定时间后,#队列仍然没有enqueue(producer仍然没有发送出任何消息)</span>
<span class="token comment">#此时producer可以继续阻塞或者将消息抛弃,此timeout值用于控制&quot;阻塞&quot;的时间</span>
<span class="token comment">#-1: 不限制阻塞超时时间，让produce一直阻塞,这个时候消息就不会被抛弃</span>
<span class="token comment">#0: 立即清空队列,消息被抛弃</span>
queue.enqueue.timeout.ms<span class="token operator">=</span>-1


<span class="token comment">#当producer接收到error ACK,或者没有接收到ACK时,允许消息重发的次数</span>
<span class="token comment">#因为broker并没有完整的机制来避免消息重复,所以当网络异常时(比如ACK丢失)</span>
<span class="token comment">#有可能导致broker接收到重复的消息,默认值为3.</span>
message.send.max.retries<span class="token operator">=</span><span class="token number">3</span>

<span class="token comment">#producer刷新topic metada的时间间隔,producer需要知道partition leader</span>
<span class="token comment">#的位置,以及当前topic的情况</span>
<span class="token comment">#因此producer需要一个机制来获取最新的metadata,当producer遇到特定错误时,</span>
<span class="token comment">#将会立即刷新</span>
<span class="token comment">#(比如topic失效,partition丢失,leader失效等),此外也可以通过此参数来配置</span>
<span class="token comment">#额外的刷新机制，默认值600000</span>
topic.metadata.refresh.interval.ms<span class="token operator">=</span><span class="token number">60000</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br></div></div><h3 id="server-properties"><a href="#server-properties" class="header-anchor">#</a> server.properties</h3> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment">#消费者集群通过连接Zookeeper来找到broker。</span>
<span class="token comment">#zookeeper连接服务器地址</span>
zookeeper.connect<span class="token operator">=</span>zk01:2181,zk02:2181,zk03:2181

<span class="token comment">#zookeeper的session过期时间，默认5000ms，用于检测消费者是否挂掉</span>
zookeeper.session.timeout.ms<span class="token operator">=</span><span class="token number">5000</span>

<span class="token comment">#当消费者挂掉，其他消费者要等该指定时间才能检查到并且触发重新负载均衡</span>
zookeeper.connection.timeout.ms<span class="token operator">=</span><span class="token number">10000</span>

<span class="token comment">#这是一个时间阈值。</span>
<span class="token comment">#指定多久消费者更新offset到zookeeper中。</span>
<span class="token comment">#注意offset更新时基于time而不是每次获得的消息。</span>
<span class="token comment">#一旦在更新zookeeper发生异常并重启，将可能拿到已拿到过的消息</span>
zookeeper.sync.time.ms<span class="token operator">=</span><span class="token number">2000</span>

<span class="token comment">#指定消费</span>
group.id<span class="token operator">=</span>xxxxx

<span class="token comment">#这是一个数量阈值，经测试是500条。</span>
<span class="token comment">#当consumer消费一定量的消息之后,将会自动向zookeeper提交offset信息#注意offset信息并不是每消费一次消息就向zk提交</span>
<span class="token comment">#一次,而是现在本地保存(内存),并定期提交,默认为true</span>
auto.commit.enable<span class="token operator">=</span>true

<span class="token comment"># 自动更新时间。默认60 * 1000</span>
auto.commit.interval.ms<span class="token operator">=</span><span class="token number">1000</span>

<span class="token comment"># 当前consumer的标识,可以设定,也可以有系统生成,</span>
<span class="token comment">#主要用来跟踪消息消费情况,便于观察</span>
conusmer.id<span class="token operator">=</span>xxx

<span class="token comment"># 消费者客户端编号，用于区分不同客户端，默认客户端程序自动产生</span>
client.id<span class="token operator">=</span>xxxx

<span class="token comment"># 最大取多少块缓存到消费者(默认10)</span>
queued.max.message.chunks<span class="token operator">=</span><span class="token number">50</span>

<span class="token comment"># 当有新的consumer加入到group时,将会reblance,此后将会</span>
<span class="token comment">#有partitions的消费端迁移到新  的consumer上,如果一个</span>
<span class="token comment">#consumer获得了某个partition的消费权限,那么它将会向zk</span>
<span class="token comment">#注册 &quot;Partition Owner registry&quot;节点信息,但是有可能</span>
<span class="token comment">#此时旧的consumer尚没有释放此节点, 此值用于控制,</span>
<span class="token comment">#注册节点的重试次数.</span>
rebalance.max.retries<span class="token operator">=</span><span class="token number">5</span>

<span class="token comment">#每拉取一批消息的最大字节数</span>
<span class="token comment">#获取消息的最大尺寸,broker不会像consumer输出大于</span>
<span class="token comment">#此值的消息chunk 每次feth将得到多条消息,此值为总大小,</span>
<span class="token comment">#提升此值,将会消耗更多的consumer端内存</span>
fetch.min.bytes<span class="token operator">=</span><span class="token number">6553600</span>

<span class="token comment">#当消息的尺寸不足时,server阻塞的时间,如果超时,</span>
<span class="token comment">#消息将立即发送给consumer</span>
<span class="token comment">#数据一批一批到达，如果每一批是10条消息，如果某一批还</span>
<span class="token comment">#不到10条，但是超时了，也会立即发送给consumer。</span>
fetch.wait.max.ms<span class="token operator">=</span><span class="token number">5000</span>
socket.receive.buffer.bytes<span class="token operator">=</span><span class="token number">655360</span>

<span class="token comment"># 如果zookeeper没有offset值或offset值超出范围。</span>
<span class="token comment">#那么就给个初始的offset。有smallest、largest、</span>
<span class="token comment">#anything可选，分别表示给当前最小的offset、</span>
<span class="token comment">#当前最大的offset、抛异常。默认largest</span>
auto.offset.reset<span class="token operator">=</span>smallest

<span class="token comment"># 指定序列化处理类</span>
derializer.class<span class="token operator">=</span>kafka.serializer.DefaultDecoder
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br></div></div><h2 id="kafka-2"><a href="#kafka-2" class="header-anchor">#</a> kafka</h2> <h3 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h3> <ol><li>顺序写 : 写数据时直接追加文件末尾</li> <li>mmap : 数据不实时写入磁盘,提高 io 效率</li> <li>零拷贝 : 读数据时使用 sendfile ,磁盘文件读到 os 内核缓冲区直接转到 socket buffer 进行网络发送</li> <li>批量压缩,批量发送</li></ol> <h3 id="丢失消息"><a href="#丢失消息" class="header-anchor">#</a> 丢失消息</h3> <ol><li>producer 丢失消息 : 调用 send 方法时由于网络原因发送失败, 解决方法 : 设置 restries 为一个合适的值,一般为3,重试时间间隔不能太小,避免网络一次波动的区间就把三次重试用完了</li> <li>consumer 丢失消息 : 自动提交 offset 时可能未来得及处理消息,offset就被提交了. 解决方法 : 关闭自动提交,消费完成后手动提交 offset</li> <li>brocker 丢失消息 : leader 所在副本宕机, follower 副本还没完全同步 leader
<ol><li>设置 acks = -1 或 all 保证 follower 副本写入消息</li> <li>保证分区至少有 3 个副本,冗余消息<code>replication.fator &gt; 3</code></li> <li>消息至少写入 2 个副本才能认为成功<code>min.insync.replicas &gt; 1</code></li> <li>避免从 LSR 中选举 leader<code>unclean.leader.election.enbale = false</code></li></ol></li></ol> <h3 id="一个-partition-只能被消费组中的一个消费者实例消费"><a href="#一个-partition-只能被消费组中的一个消费者实例消费" class="header-anchor">#</a> 一个 partition 只能被消费组中的一个消费者实例消费</h3> <p>要在 partition 级别提供顺序消费,如果多个 consumer 消费一个 partition,即使 kafka 是顺序分发数据的,但由于网络延迟等情况, consumer 并不能保证按 kafka 的分发顺序接收到数据,这样达到顺序消费就无法保证.</p> <p>通过二分查找定位消息在哪个 segment.对每个 segment 创建索引文件,每条记录是一个 kv 组(k 是消息 offset,v是 segment 中的偏移量)</p> <h3 id="查询过程"><a href="#查询过程" class="header-anchor">#</a> 查询过程</h3> <ol><li>利用二分查找找到消息的 segment 文件</li> <li>读取 index 文件找到 segment 中的位置</li> <li>读取 segment 文件中对应位置数据</li></ol> <h3 id="稀疏索引"><a href="#稀疏索引" class="header-anchor">#</a> 稀疏索引</h3> <p>并不是所有消息都会在 index 文件中记录 position,每间隔 N 条消息记录一条.虽然不能查到精确位置,但可以利用二分查找,找到距离消息最近的消息的位置</p> <h2 id="pulsar"><a href="#pulsar" class="header-anchor">#</a> pulsar</h2> <p>解决 kafka 扩容难度大问题,将服务层和存储层解藕,无状态的 broker 负责数据服务, bookie(bookeeper系统上的节点) 节点负责数据存储.计算、存储分离的消息系统</p> <blockquote><p>bookeeper 为日志存储打造的系统</p></blockquote> <p>broker是无状态的用户消息到达时调用 bookeeper 接口写数据,要查询数据时调 bookeeper 接口查数据,同时做一些缓存.依赖 zookeeper 保存元数据的关系.虽然 broker 是无状态的但是只有将消息发送到同一个 broker 才能保证消息顺序写入.即每个 partition 生产必须对应同一台 broker.当某台 broker 挂了,可以立刻把 partition 对应的 broker 切换到另一个 broker 上,只要保证只有一个 broker 对 topic-partition-x 有写权限就行.不会发生数据迁移.</p> <h3 id="写数据"><a href="#写数据" class="header-anchor">#</a> 写数据</h3> <ol><li>节点数 n : bookeeper 集群到 bookie 数</li> <li>副本数 m : 某一个 ledger 会写入到 n 个 bookie 中的 m 个里,即 m 个副本</li> <li>确认写入数 t : 每次向 ledger 写入数据时(并发写入到 m 个 bookie) 需要确保收到 t 个 ack 才返回成功.</li></ol> <blockquote><p>相当于把 kafka 的某个 partition 的 segment 均匀的分布到了多个存储节点上.扩容时快速添加机器,让新的 segment 存储到合适的 bookie 上,只要记住 segment 和 bookie 的关系就可以了.</p></blockquote> <h3 id="消费模型"><a href="#消费模型" class="header-anchor">#</a> 消费模型</h3> <p>kafka 一个 partition 对应一个 consumer. pulsar 通过 subscription 支持 4 种消费方式.</p> <table><thead><tr><th>消费模式</th> <th>备注</th></tr></thead> <tbody><tr><td>exclusive</td> <td>消费组里仅有一个 consumer 能够消费,其它根本连不上 pulsar</td></tr> <tr><td>failover</td> <td>消费组里的每个消费者都能连上 partition 所在的 broker,但仅有一个能消费到数据,如果挂了,会从其它消费者中选举</td></tr> <tr><td>shared</td> <td>消费者中的所有消费者都能消费 topic 下所有 patition,消息以 round-robin (循环) 方式分发</td></tr> <tr><td>key-shard</td> <td>消费者中的所有消费者都能消费 topic 下所有 patition,但是带有相同 key 的消息会保证发送给同一个消费者</td></tr></tbody></table></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新:</span> <span class="time">6/18/2021, 2:43:25 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/m/设计模式/权限系统.html" class="prev">
        权限系统
      </a></span> <span class="next"><a href="/m/设计模式/点赞签到.html">
        点赞签到
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/m/assets/js/app.71fdaff2.js" defer></script><script src="/m/assets/js/2.351ead77.js" defer></script><script src="/m/assets/js/10.98c1e7e0.js" defer></script>
  </body>
</html>
